type AuthApiKey {
	"The unique identifier of the entity."
	id: ID!
}

"User authentication session."
type AuthenticationSession {
	id: String!
	"Type of application used to authenticate."
	type: AuthenticationSessionType!
	"IP address."
	ip: String
	"Location country name."
	locationCountry: String
	"Location country code."
	locationCountryCode: String
	"Country codes of all seen locations."
	countryCodes: [String!]!
	"Location city name."
	locationCity: String
	"Session's user-agent."
	userAgent: String
	"Used web browser."
	browserType: String
	"When was the session last seen"
	lastActiveAt: DateTime
	"Date when the session was created."
	createdAt: DateTime!
	"Date when the session was last updated."
	updatedAt: DateTime!
	"Human readable location"
	location: String
	"Operating system used for the session"
	operatingSystem: String
	"Client used for the session"
	client: String
	"Name of the session, derived from the client and operating system"
	name: String!
}

enum AuthenticationSessionType {
	web
	desktop
	ios
	android
}

"Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) "
scalar DateTime

"An email address that can be used for submitting issues."
type AuthEmailIntakeAddress {
	"The unique identifier of the entity."
	id: ID!
	"Unique email address user name (before @) used for incoming email."
	address: String!
	"Whether the email address is enabled."
	enabled: Boolean!
	"The auth organization that the email address is associated with."
	organization: AuthOrganization!
	"The auth user who created the email intake address."
	creator: AuthUser
}

type AuthIntegration {
	"The unique identifier of the entity."
	id: ID!
}

type AuthorizedApplicationBase {
	"Application name."
	name: String!
	"Image of the application."
	imageUrl: String
	"Scopes that are authorized for this application for a given user."
	scope: [String!]!
	"OAuth application's ID."
	appId: String!
	"OAuth application's client ID."
	clientId: String!
}

"[INTERNAL] An OAuth userId/createdDate tuple"
type AuthMembership {
	"The authorizing userId"
	userId: String!
	"The date of the authorization"
	createdAt: DateTime!
}

type AuthOauthClientWithTokens {
	"The auth OAuth client."
	client: AuthOauthClient!
	"The token matching the app, scope, and actor."
	tokens: [OauthToken!]!
}

type AuthOauthClient {
	"The unique identifier of the entity."
	id: ID!
	"OAuth application's client ID."
	clientId: String!
	"OAuth application's client name."
	name: String!
	"Information about the application."
	description: String
	"Name of the developer."
	developer: String!
	"Url of the developer."
	developerUrl: String!
	"Image of the application."
	imageUrl: String
	"OAuth application's client secret."
	clientSecret: String!
	"List of allowed redirect URIs for the application."
	redirectUris: [String!]!
	"Whether the OAuth application can be installed in other organizations."
	publicEnabled: Boolean!
	"The ID of the user who created the OAuth application."
	creatorId: String!
	"The ID of the workspace the OAuth application belongs to."
	organizationId: String!
	"Webhook URL"
	webhookUrl: String
	archivedAt: DateTime
}

"AuthOauthClient with scope from OauthToken, for use in the GraphQL API."
type AuthOauthClientWithScope {
	"Application name."
	name: String!
	"Image of the application."
	imageUrl: String
	"Scopes that are authorized for this application for a given user."
	scope: [String!]!
	"OAuth application's ID."
	appId: String!
	"OAuth application's client ID."
	clientId: String!
	"The application's webhook URL."
	webhookUrl: String
}

"AuthOauthClient with token creator IDs and counts (memberships), for use in the GraphQL API."
type AuthOauthClientWithMemberships {
	"Application name."
	name: String!
	"Image of the application."
	imageUrl: String
	"Scopes that are authorized for this application for a given user."
	scope: [String!]!
	"OAuth application's ID."
	appId: String!
	"OAuth application's client ID."
	clientId: String!
	"The application's webhook URL."
	webhookUrl: String
	"Total number of members that authorized the application."
	totalMembers: Float!
	"User IDs and membership dates of everyone who has authorized the application with the set of scopes."
	memberships: [AuthMembership!]!
}

"An organization. Organizations are root-level objects that contain users and teams."
type AuthOrganization {
	"The unique identifier of the entity."
	id: ID!
	"The organization's name."
	name: String!
	"The organization's unique URL key."
	urlKey: String!
	"Previously used URL keys for the organization (last 3 are kept and redirected)."
	previousUrlKeys: [String!]!
	"The organization's logo URL."
	logoUrl: String
	"The time at which deletion of the organization was requested."
	deletionRequestedAt: DateTime
	"The feature release channel the organization belongs to."
	releaseChannel: ReleaseChannel!
	"Whether SAML authentication is enabled for organization."
	samlEnabled: Boolean!
	"[INTERNAL] SAML settings"
	samlSettings: JSONObject
	"Allowed authentication providers, empty array means all are allowed"
	allowedAuthServices: [String!]!
	"Whether SCIM provisioning is enabled for organization."
	scimEnabled: Boolean!
	"The email domain or URL key for the organization."
	serviceId: String!
	"The region the organization is hosted in."
	region: String!
	userCount: Float!
}

"Features release channel."
enum ReleaseChannel {
	internal
	beta
	preRelease
	public
}

"The `JSONObject` scalar type represents arbitrary values as *embedded* JSON"
scalar JSONObject

type AuthOrganizationDomain {
	"The unique identifier of the entity."
	id: ID!
	organizationId: String!
	name: String!
	verified: Boolean!
	claimed: Boolean
	authType: OrganizationDomainAuthType!
}

"What type of auth is the domain used for."
enum OrganizationDomainAuthType {
	saml
	general
}

"An invitation to the organization that has been sent via email."
type AuthOrganizationInvite {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the invite will be expiring. Null, if the invite shouldn't expire."
	expiresAt: DateTime
}

"A user that has access to the the resources of an organization."
type AuthUser {
	id: ID!
	"The user's full name."
	name: String!
	"The user's display (nick) name. Unique within each organization."
	displayName: String!
	"The user's email address."
	email: String!
	"An URL to the user's avatar image."
	avatarUrl: String
	"Whether the user is active."
	active: Boolean!
	"User account ID the user belongs to."
	userAccountId: String!
	"Organization the user belongs to."
	organization: AuthOrganization!
}

type OauthToken {
	id: Float!
	revokedAt: DateTime
	createdAt: DateTime!
	"OAuth2 client for which the access token belongs to."
	client: AuthOauthClient!
	clientId: String!
	"Auth user who authorized the OAuth application."
	user: AuthUser!
	"Id of the user who authorized the OAuth application."
	userId: String!
}

"A user account."
type UserAccount {
	"The models identifier."
	id: ID!
	"The time at which the model was created."
	createdAt: DateTime!
	"The time at which the model was updated."
	updatedAt: DateTime!
	"The time at which the model was archived."
	archivedAt: DateTime
	"The user's name."
	name: String
	"The user's email address."
	email: String!
	"The authentication service used to create the account."
	service: String!
	"Whether not to send email auth links in the email auth emails."
	authTokenLinkDisabled: Boolean!
}

"[INTERNAL] An email change verification challenge."
type UserAccountEmailChange {
	"The model's identifier."
	id: ID!
	"The time at which the model was updated."
	updatedAt: DateTime!
	"The time at which the model was archived."
	archivedAt: DateTime
	"The user account's current email."
	oldEmail: String!
	"The timestamp the old email was verified at."
	oldEmailVerifiedAt: DateTime
	"The new email the user account wants to change to."
	newEmail: String!
	"The timestamp the new email was verified at."
	newEmailVerifiedAt: DateTime
	"The timestamp the verification codes expire at."
	expiresAt: DateTime!
	"The timestamp this verification challenge was canceled at."
	canceledAt: DateTime
}

type PageInfo {
	"Indicates if there are more results when paginating backward."
	hasPreviousPage: Boolean!
	"Indicates if there are more results when paginating forward."
	hasNextPage: Boolean!
	"Cursor representing the first result in the paginated results."
	startCursor: String
	"Cursor representing the last result in the paginated results."
	endCursor: String
}

"An API key. Grants access to the user's resources."
type ApiKey implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The label of the API key."
	label: String!
}

type ApiKeyEdge {
	node: ApiKey!
	"Used in `before` and `after` args"
	cursor: String!
}

type ApiKeyConnection {
	edges: [ApiKeyEdge!]!
	nodes: [ApiKey!]!
	pageInfo: PageInfo!
}

"A user that has access to the the resources of an organization."
type User implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user's full name."
	name: String!
	"The user's display (nick) name. Unique within each organization."
	displayName: String!
	"The user's email address."
	email: String!
	"An URL to the user's avatar image."
	avatarUrl: String
	"Reason why is the account disabled."
	disableReason: String
	"Unique hash for the user to be used in invite URLs."
	inviteHash: String!
	"[DEPRECATED] Hash for the user to be used in calendar URLs."
	calendarHash: String
	"A short description of the user, either its title or bio."
	description: String
	"The emoji to represent the user current status."
	statusEmoji: String
	"The label of the user current status."
	statusLabel: String
	"A date at which the user current status should be cleared."
	statusUntilAt: DateTime
	"The local timezone of the user."
	timezone: String
	"Organization the user belongs to."
	organization: Organization!
	"The last time the user was seen online. If null, the user is currently online."
	lastSeen: DateTime
	"Whether the user is a guest in the workspace and limited to accessing a subset of teams."
	guest: Boolean!
	"Whether the user account is active or disabled (suspended)."
	active: Boolean!
	"User's profile URL."
	url: String!
	"Issues assigned to the user."
	assignedIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Issues created by the user."
	createdIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Number of issues created."
	createdIssueCount: Int!
	"Teams the user is part of."
	teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"Memberships associated with the user. For easier access of the same data, use `teams` query."
	teamMemberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
	"Whether the user is the currently authenticated user."
	isMe: Boolean!
	"Whether the user is an organization administrator."
	admin: Boolean!
}

"By which field should the pagination order by"
enum PaginationOrderBy {
	createdAt
	updatedAt
}

type UserEdge {
	node: User!
	"Used in `before` and `after` args"
	cursor: String!
}

type UserConnection {
	edges: [UserEdge!]!
	nodes: [User!]!
	pageInfo: PageInfo!
}

"Issue attachment (e.g. support ticket, pull request)."
type Attachment implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Content for the title line in the Linear attachment widget."
	title: String!
	"Content for the subtitle line in the Linear attachment widget."
	subtitle: String
	"Location of the attachment which is also used as an identifier."
	url: String!
	"The creator of the attachment."
	creator: User
	"The non-Linear user who created the attachment."
	externalUserCreator: ExternalUser
	"Custom metadata related to the attachment."
	metadata: JSONObject!
	"Information about the source which created the attachment."
	source: JSONObject
	"An accessor helper to source.type, defines the source type of the attachment."
	sourceType: String
	"Indicates if attachments for the same source application should be grouped in the Linear UI."
	groupBySource: Boolean!
	"The issue this attachment belongs to."
	issue: Issue!
}

type AttachmentEdge {
	node: Attachment!
	"Used in `before` and `after` args"
	cursor: String!
}

type AttachmentConnection {
	edges: [AttachmentEdge!]!
	nodes: [Attachment!]!
	pageInfo: PageInfo!
}

"Workspace audit log entry object."
type AuditEntry implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	type: String!
	"The organization the audit log belongs to."
	organization: Organization
	"The user that caused the audit entry to be created."
	actor: User
	"The ID of the user that caused the audit entry to be created."
	actorId: String
	"IP from actor when entry was recorded."
	ip: String
	"Country code of request resulting to audit entry."
	countryCode: String
	"Additional metadata related to the audit entry."
	metadata: JSONObject
	"Additional information related to the request which performed the action."
	requestInformation: JSONObject
}

"A update associated with an project."
type ProjectUpdate implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The update content in markdown format."
	body: String!
	"The project that the update is associated with."
	project: Project!
	"The health of the project at the time of the update."
	health: ProjectUpdateHealthType!
	"The user who wrote the update."
	user: User!
	"The time the project update was edited."
	editedAt: DateTime
	"[Internal] Serialized JSON representing current state of the project properties when posting the project update."
	infoSnapshot: JSONObject
	"Whether project update diff should be hidden."
	isDiffHidden: Boolean!
	"[Internal] The content of the project update as a Prosemirror document."
	bodyData: String!
	"The URL to the project update."
	url: String!
	"The diff between the current update and the previous one."
	diff: JSONObject
	"The diff between the current update and the previous one, formatted as markdown."
	diffMarkdown: String
}

"The health type of a project when the update is created."
enum ProjectUpdateHealthType {
	onTrack
	atRisk
	offTrack
}

type ProjectUpdateEdge {
	node: ProjectUpdate!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectUpdateConnection {
	edges: [ProjectUpdateEdge!]!
	nodes: [ProjectUpdate!]!
	pageInfo: PageInfo!
}

"A project."
type Project implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The project's name."
	name: String!
	"The project's description."
	description: String!
	"The project's unique URL slug."
	slugId: String!
	"The icon of the project."
	icon: String
	"The project's color."
	color: String!
	"The status that the project is associated with."
	status: ProjectStatus!
	"The user who created the project."
	creator: User
	"The project lead."
	lead: User
	"The time until which project update reminders are paused."
	projectUpdateRemindersPausedUntilAt: DateTime
	"The estimated start date of the project."
	startDate: TimelessDate
	"[INTERNAL] The resolution of the project's start date."
	startDateResolution: DateResolutionType
	"The estimated completion date of the project."
	targetDate: TimelessDate
	"[INTERNAL] The resolution of the project's estimated completion date."
	targetDateResolution: DateResolutionType
	"The time at which the project was moved into started state."
	startedAt: DateTime
	"The time at which the project was moved into completed state."
	completedAt: DateTime
	"The time at which the project was moved into canceled state."
	canceledAt: DateTime
	"The time at which the project was automatically archived by the auto pruning process."
	autoArchivedAt: DateTime
	"A flag that indicates whether the project is in the trash bin."
	trashed: Boolean
	"The sort order for the project within the organization."
	sortOrder: Float!
	"The project was created based on this issue."
	convertedFromIssue: Issue
	"The last template that was applied to this project."
	lastAppliedTemplate: Template
	"The total number of issues in the project after each week."
	issueCountHistory: [Float!]!
	"The number of completed issues in the project after each week."
	completedIssueCountHistory: [Float!]!
	"The total number of estimation points after each week."
	scopeHistory: [Float!]!
	"The number of completed estimation points after each week."
	completedScopeHistory: [Float!]!
	"The number of in progress estimation points after each week."
	inProgressScopeHistory: [Float!]!
	"Whether to send new issue notifications to Slack."
	slackNewIssue: Boolean!
	"Whether to send new issue comment notifications to Slack."
	slackIssueComments: Boolean!
	"Whether to send new issue status updates to Slack."
	slackIssueStatuses: Boolean!
	"The user's favorite associated with this project."
	favorite: Favorite
	"Project URL."
	url: String!
	"Teams associated with this project."
	teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"Users that are members of the project."
	members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"Project updates associated with the project."
	projectUpdates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
	"Documents associated with the project."
	documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
	"Milestones associated with the project."
	projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
	"Issues associated with the project."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Links associated with the project."
	links(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLinkConnection!
	"The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points."
	progress: Float!
	"The overall scope (total estimate points) of the project."
	scope: Float!
	"Settings for all integrations associated with that project."
	integrationsSettings: IntegrationsSettings
	"The project's content in markdown format."
	content: String
	"[Internal] The project's content as YJS state."
	contentState: String
	"[DEPRECATED] The type of the state."
	state: String! @deprecated(reason: "Use project.status instead")
}

"Represents a date in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) "
scalar TimelessDate

"[INTERNAL] By which resolution is a date defined."
enum DateResolutionType {
	month
	quarter
	halfYear
	year
}

type ProjectEdge {
	node: Project!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectConnection {
	edges: [ProjectEdge!]!
	nodes: [Project!]!
	pageInfo: PageInfo!
}

"A reaction associated with a comment or a project update."
type Reaction implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Name of the reaction's emoji."
	emoji: String!
	"The issue that the reaction is associated with."
	issue: Issue
	"The comment that the reaction is associated with."
	comment: Comment
	"The project update that the reaction is associated with."
	projectUpdate: ProjectUpdate
	"The user that created the reaction."
	user: User
}

"A comment associated with an issue."
type Comment implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The comment content in markdown format."
	body: String!
	"The issue that the comment is associated with."
	issue: Issue
	"The document content that the comment is associated with."
	documentContent: DocumentContent
	"The project update that the comment is associated with."
	projectUpdate: ProjectUpdate
	"The parent comment under which the current comment is nested."
	parent: Comment
	"The user that resolved the thread."
	resolvingUser: User
	"The time the resolvingUser resolved the thread."
	resolvedAt: DateTime
	"The comment that resolved the thread."
	resolvingComment: Comment
	"The user who wrote the comment."
	user: User
	"The external user who wrote the comment."
	externalUser: ExternalUser
	"The time user edited the comment."
	editedAt: DateTime
	"[Internal] The comment content as a Prosemirror document."
	bodyData: String!
	"The text that this comment references. Only defined for inline comments."
	quotedText: String
	"[Internal] Summary for comment thread."
	summaryText: String
	"Emoji reaction summary, grouped by emoji type."
	reactionData: JSONObject!
	"Comment's URL."
	url: String!
	"The children of the comment."
	children(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
	"The bot that created the comment."
	botActor: ActorBot
}

type CommentEdge {
	node: Comment!
	"Used in `before` and `after` args"
	cursor: String!
}

type CommentConnection {
	edges: [CommentEdge!]!
	nodes: [Comment!]!
	pageInfo: PageInfo!
}

"A company related to issue's origin."
type Company implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Company name."
	name: String!
	"Company ID in an external system."
	externalId: String!
	"Company website URL."
	websiteUrl: String
	"Company logo URL."
	logoUrl: String
	"The user who added the company."
	creator: User!
	"The organization of the customer."
	organization: Organization!
	"Custom company properties."
	companyProperties: JSONObject!
}

type CompanyEdge {
	node: Company!
	"Used in `before` and `after` args"
	cursor: String!
}

type CompanyConnection {
	edges: [CompanyEdge!]!
	nodes: [Company!]!
	pageInfo: PageInfo!
}

"A custom view that has been saved by a user."
type CustomView implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the custom view."
	name: String!
	"The description of the custom view."
	description: String
	"The icon of the custom view."
	icon: String
	"The color of the icon of the custom view."
	color: String
	"The organization of the custom view."
	organization: Organization!
	"The team associated with the custom view."
	team: Team
	"The user who created the custom view."
	creator: User!
	"The user who owns the custom view."
	owner: User!
	"The user who last updated the custom view."
	updatedBy: User!
	"The filters applied to issues in the custom view."
	filters: JSONObject! @deprecated(reason: "Will be replaced by `filterData` in a future update")
	"The filter applied to issues in the custom view."
	filterData: JSONObject!
	"The filter applied to projects in the custom view."
	projectFilterData: JSONObject
	"Whether the custom view is shared with everyone in the organization."
	shared: Boolean!
	"The model name of the custom view."
	modelName: String!
	"Issues associated with the custom view."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [IssueSortInput!]): IssueConnection!
}

type CustomViewEdge {
	node: CustomView!
	"Used in `before` and `after` args"
	cursor: String!
}

type CustomViewConnection {
	edges: [CustomViewEdge!]!
	nodes: [CustomView!]!
	pageInfo: PageInfo!
}

"A bot actor is an actor that is not a user, but an application or integration."
type ActorBot {
	id: ID
	"The type of bot."
	type: String!
	"The sub type of the bot."
	subType: String
	"The display name of the bot."
	name: String
	"The display name of the external user on behalf of which the bot acted."
	userDisplayName: String
	"A url pointing to the avatar representing this bot."
	avatarUrl: String
}

"An issue."
type Issue implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The issue's unique number."
	number: Float!
	"The issue's title."
	title: String!
	"The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low."
	priority: Float!
	"The estimate of the complexity of the issue.."
	estimate: Float
	"The order of the item in its column on the board."
	boardOrder: Float! @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")
	"The order of the item in relation to other items in the organization."
	sortOrder: Float!
	"The time at which the issue was moved into started state."
	startedAt: DateTime
	"The time at which the issue was moved into completed state."
	completedAt: DateTime
	"The time at which the issue entered triage."
	startedTriageAt: DateTime
	"The time at which the issue left triage."
	triagedAt: DateTime
	"The time at which the issue was moved into canceled state."
	canceledAt: DateTime
	"The time at which the issue was automatically closed by the auto pruning process."
	autoClosedAt: DateTime
	"The time at which the issue was automatically archived by the auto pruning process."
	autoArchivedAt: DateTime
	"The date at which the issue is due."
	dueDate: TimelessDate
	"[Internal] The time at which the issue's SLA began."
	slaStartedAt: DateTime
	"[Internal] The time at which the issue's SLA will breach."
	slaBreachesAt: DateTime
	"A flag that indicates whether the issue is in the trash bin."
	trashed: Boolean
	"The time until an issue will be snoozed in Triage view."
	snoozedUntilAt: DateTime
	"Id of the labels associated with this issue."
	labelIds: [String!]!
	"The team that the issue is associated with."
	team: Team!
	"The cycle that the issue is associated with."
	cycle: Cycle
	"The project that the issue is associated with."
	project: Project
	"The projectMilestone that the issue is associated with."
	projectMilestone: ProjectMilestone
	"The last template that was applied to this issue."
	lastAppliedTemplate: Template
	"Previous identifiers of the issue if it has been moved between teams."
	previousIdentifiers: [String!]!
	"The user who created the issue."
	creator: User
	"The external user who created the issue."
	externalUserCreator: ExternalUser
	"The user to whom the issue is assigned to."
	assignee: User
	"The user who snoozed the issue."
	snoozedBy: User
	"The workflow state that the issue is associated with."
	state: WorkflowState!
	"The order of the item in the sub-issue list. Only set if the issue has a parent."
	subIssueSortOrder: Float
	"Label for the priority."
	priorityLabel: String!
	"The comment that this issue was created from."
	sourceComment: Comment
	"Integration type that created this issue, if applicable."
	integrationSourceType: IntegrationService
	"The bot that created the issue, if applicable."
	botActor: ActorBot
	"The users favorite associated with this issue."
	favorite: Favorite
	"Issue's human readable identifier (e.g. ENG-123)."
	identifier: String!
	"Issue URL."
	url: String!
	"Suggested branch name for the issue."
	branchName: String!
	"Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk)."
	customerTicketCount: Int!
	"Users who are subscribed to the issue."
	subscribers(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"The parent of the issue."
	parent: Issue
	"Children of the issue."
	children(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Comments associated with the issue."
	comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
	"History entries associated with the issue."
	history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueHistoryConnection!
	"Labels associated with this issue."
	labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
	"Relations associated with this issue."
	relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
	"Inverse relations associated with this issue."
	inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
	"Attachments associated with the issue."
	attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
	"The issue's description in markdown format."
	description: String
	"[Internal] The issue's description as a Prosemirror document."
	descriptionData: JSON @deprecated(reason: "Use description instead.")
	"[Internal] The issue's description content as YJS state."
	descriptionState: String
}

"Linear supported integration services."
enum IntegrationService {
	airbyte
	discord
	figma
	figmaPlugin
	front
	github
	githubCommit
	githubPersonal
	gitlab
	googleCalendarPersonal
	googleSheets
	intercom
	jira
	jiraPersonal
	loom
	notion
	opsgenie
	pagerDuty
	slack
	slackAsks
	slackOrgProjectUpdatesPost
	slackPersonal
	slackPost
	slackProjectPost
	slackProjectUpdatesPost
	sentry
	zendesk
}

"The `JSON` scalar type represents arbitrary values as *stringified* JSON"
scalar JSON

type IssueEdge {
	node: Issue!
	"Used in `before` and `after` args"
	cursor: String!
}

type IssueConnection {
	edges: [IssueEdge!]!
	nodes: [Issue!]!
	pageInfo: PageInfo!
}

"A set of issues to be resolved in a specified amount of time."
type Cycle implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The number of the cycle."
	number: Float!
	"The custom name of the cycle."
	name: String
	"The cycle's description."
	description: String
	"The start time of the cycle."
	startsAt: DateTime!
	"The end time of the cycle."
	endsAt: DateTime!
	"The completion time of the cycle. If null, the cycle hasn't been completed."
	completedAt: DateTime
	"The time at which the cycle was automatically archived by the auto pruning process."
	autoArchivedAt: DateTime
	"The total number of issues in the cycle after each day."
	issueCountHistory: [Float!]!
	"The number of completed issues in the cycle after each day."
	completedIssueCountHistory: [Float!]!
	"The total number of estimation points after each day."
	scopeHistory: [Float!]!
	"The number of completed estimation points after each day."
	completedScopeHistory: [Float!]!
	"The number of in progress estimation points after each day."
	inProgressScopeHistory: [Float!]!
	"The team that the cycle is associated with."
	team: Team!
	"Issues associated with the cycle."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Issues that weren't completed when the cycle was closed."
	uncompletedIssuesUponClose(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points."
	progress: Float!
}

type CycleEdge {
	node: Cycle!
	"Used in `before` and `after` args"
	cursor: String!
}

type CycleConnection {
	edges: [CycleEdge!]!
	nodes: [Cycle!]!
	pageInfo: PageInfo!
}

"A document for a project."
type Document implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The document title."
	title: String!
	"The icon of the document."
	icon: String
	"The color of the icon."
	color: String
	"The user who created the document."
	creator: User!
	"The user who last updated the document."
	updatedBy: User!
	"The project that the document is associated with."
	project: Project!
	"The document's unique URL slug."
	slugId: String!
	"The last template that was applied to this document."
	lastAppliedTemplate: Template
	"The time at which the document was hidden. Null if the entity has not been hidden."
	hiddenAt: DateTime
	"The order of the item in the project resources list."
	sortOrder: Float!
	"The documents content in markdown format."
	content: String
	"[Internal] The documents content as YJS state."
	contentState: String
	"[Internal] The documents content as a Prosemirror document."
	contentData: JSON @deprecated(reason: "Use content instead.")
}

type DocumentEdge {
	node: Document!
	"Used in `before` and `after` args"
	cursor: String!
}

type DocumentConnection {
	edges: [DocumentEdge!]!
	nodes: [Document!]!
	pageInfo: PageInfo!
}

"A document content history for a document."
type DocumentContentHistory implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The document content that this history item is associated with."
	documentContent: DocumentContent!
	"[Internal] The document content as a Prosemirror document."
	contentData: JSONObject
	"IDs of actors whose edits went into this history item."
	actorIds: [String!]!
	"The timestamp associated with the DocumentContent when it was originally saved."
	contentDataSnapshotAt: DateTime!
}

"A document content for a project."
type DocumentContent implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The document content in markdown format."
	content: String
	"[Internal] The document content as a Prosemirror document."
	contentData: JSONObject @deprecated(reason: "Use `contentState` instead")
	"The document content state as a base64 encoded string."
	contentState: String
	"The issue that the content is associated with."
	issue: Issue
	"The project that the content is associated with."
	project: Project
	"The project milestone that the content is associated with."
	projectMilestone: ProjectMilestone
	"The document that the content is associated with."
	document: Document
	"The time at which the document content was restored from a previous version."
	restoredAt: DateTime
}

"An email address that can be used for submitting issues."
type EmailIntakeAddress implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Unique email address user name (before @) used for incoming email."
	address: String!
	"Whether the email address is enabled."
	enabled: Boolean!
	"The template that the email address is associated with."
	template: Template
	"The team that the email address is associated with."
	team: Team!
	"The organization that the email address is associated with."
	organization: Organization!
	"The user who created the email intake address."
	creator: User
}

"A custom emoji."
type Emoji implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The emoji's name."
	name: String!
	"The emoji image URL."
	url: String!
	"The source of the emoji."
	source: String!
	"The user who created the emoji."
	creator: User!
	"The organization that the emoji belongs to."
	organization: Organization!
}

type EmojiEdge {
	node: Emoji!
	"Used in `before` and `after` args"
	cursor: String!
}

type EmojiConnection {
	edges: [EmojiEdge!]!
	nodes: [Emoji!]!
	pageInfo: PageInfo!
}

"Join table between templates and integrations."
type IntegrationTemplate implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The template that the integration is associated with."
	template: Template!
	"The integration that the template is associated with."
	integration: Integration!
	"ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID."
	foreignEntityId: String
}

type IntegrationTemplateEdge {
	node: IntegrationTemplate!
	"Used in `before` and `after` args"
	cursor: String!
}

type IntegrationTemplateConnection {
	edges: [IntegrationTemplateEdge!]!
	nodes: [IntegrationTemplate!]!
	pageInfo: PageInfo!
}

"Tuple for mapping Slack channel IDs to names."
type SlackAsksTeamSettings {
	"The Linear team ID."
	id: String!
	"Whether the default Asks template is enabled in the given channel for this team."
	hasDefaultAsk: Boolean!
}

"Object for mapping Slack channel IDs to names and other settings."
type SlackChannelNameMapping {
	"The Slack channel ID."
	id: String!
	"The Slack channel name."
	name: String!
	"Whether or not the Slack channel is private."
	isPrivate: Boolean
	"Whether or not the Slack channel is shared with an external org."
	isShared: Boolean
	"Whether or not we the Linear Asks bot has been added to this Slack channel."
	botAdded: Boolean
	"Which teams are connected to the channel and settings for those teams."
	teams: [SlackAsksTeamSettings!]!
	"Whether or not top-level messages in this channel should automatically create Asks."
	autoCreateOnMessage: Boolean
	"Whether or not using the :ticket: emoji in this channel should automatically create Asks."
	autoCreateOnEmoji: Boolean
	"Whether or not @-mentioning the bot should automatically create an Ask with the message."
	autoCreateOnBotMention: Boolean
	"The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template."
	autoCreateTemplateId: String
}

"Shared Slack integration settings."
type SharedSlackSettings {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
}

"Slack Asks specific settings."
type SlackAsksSettings {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
	"The mapping of Slack channel ID => Slack channel name for connected channels."
	slackChannelMapping: [SlackChannelNameMapping!]
	"The user role type that is allowed to manage Asks settings."
	canAdministrate: UserRoleType!
}

"The different permission roles available to users on an organization."
enum UserRoleType {
	admin
	guest
	user
}

"Intercom specific settings."
type IntercomSettings {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
}

"Front specific settings."
type FrontSettings {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
}

"Settings for the regular Slack integration."
type SlackSettings {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
	"Whether Linear should automatically respond with issue unfurls when an issue identifier is mentioned in a Slack message."
	linkOnIssueIdMention: Boolean!
}

"Slack notification specific settings."
type SlackPostSettings {
	channel: String!
	channelId: String!
	configurationUrl: String!
	channelType: SlackChannelType
}

enum SlackChannelType {
	DirectMessage
	MultiPersonDirectMessage
	Private
	Public
}

"Metadata and settings for a GitHub integration."
type GitHubSettings {
	"The avatar URL for the GitHub organization."
	orgAvatarUrl: String!
	"The GitHub organization's name."
	orgLogin: String!
	"The names of the repositories connected for the GitHub integration."
	repositories: [GitHubRepo!]
	"Mapping of team to repository for syncing."
	repositoriesMapping: [TeamRepoMapping!]
}

"Metadata and settings for a GitHub Personal integration."
type GitHubPersonalSettings {
	"The GitHub user's name."
	login: String!
}

"GitHub repos available to sync."
type GitHubRepo {
	"The full name of the repository."
	fullName: String!
	"The GitHub repo id."
	id: Float!
}

"Mapping of Linear teams to GitHub repos."
type TeamRepoMapping {
	"The Linear team id to map to the given project."
	linearTeamId: String!
	"The GitHub repo id."
	gitHubRepoId: Float!
	"Whether the sync for this mapping is bidirectional."
	bidirectional: Boolean
	"Whether this mapping is the default one for issue creation."
	default: Boolean
}

"Metadata and settings for a GitLab integration."
type GitLabSettings {
	"The self-hosted URL of the GitLab instance."
	url: String
	"Whether the token is limited to a read-only scope."
	readonly: Boolean
	"The ISO timestamp the GitLab access token expires."
	expiresAt: String
}

"Google Sheets specific settings."
type GoogleSheetsSettings {
	spreadsheetId: String!
	spreadsheetUrl: String!
	sheetId: Float!
	updatedIssuesAt: DateTime!
}

"Metadata about a Jira project."
type JiraProjectData {
	"The Jira id for this project."
	id: String!
	"The Jira key for this project, such as ENG."
	key: String!
	"The Jira name for this project, such as Engineering."
	name: String!
}

"Tuple for mapping Jira projects to Linear teams."
type JiraLinearMapping {
	"The Jira id for this project."
	jiraProjectId: String!
	"The Linear team id to map to the given project."
	linearTeamId: String!
	"Whether the sync for this mapping is bidirectional."
	bidirectional: Boolean
	"Whether this mapping is the default one for issue creation."
	default: Boolean
}

"Jira specific settings."
type JiraSettings {
	"The mapping of Jira project id => Linear team id."
	projectMapping: [JiraLinearMapping!]
	"The Jira projects for the organization."
	projects: [JiraProjectData!]!
	"Whether this integration is for Jira Server or not."
	isJiraServer: Boolean
}

"Jira personal specific settings."
type JiraPersonalSettings {
	"The name of the Jira site currently authorized through the integration."
	siteName: String
}

"Notion specific settings."
type NotionSettings {
	"The ID of the Notion workspace being connected."
	workspaceId: String!
	"The name of the Notion workspace being connected."
	workspaceName: String!
}

"Opsgenie specific settings."
type OpsgenieSettings {
	"The date when the Opsgenie API failed with an unauthorized error."
	apiFailedWithUnauthorizedErrorAt: DateTime!
}

"PagerDuty specific settings."
type PagerDutySettings {
	"The date when the PagerDuty API failed with an unauthorized error."
	apiFailedWithUnauthorizedErrorAt: DateTime!
}

"Sentry specific settings."
type SentrySettings {
	"The slug of the Sentry organization being connected."
	organizationSlug: String!
}

"Zendesk specific settings."
type ZendeskSettings {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
	"The subdomain of the Zendesk organization being connected."
	subdomain: String!
	"The URL of the connected Zendesk organization."
	url: String!
	"The ID of the Linear bot user."
	botUserId: String
}

"The integration resource's settings."
type IntegrationSettings {
	slack: SlackSettings
	slackAsks: SlackAsksSettings
	slackPost: SlackPostSettings
	slackProjectPost: SlackPostSettings
	slackOrgProjectUpdatesPost: SlackPostSettings
	googleSheets: GoogleSheetsSettings
	gitHub: GitHubSettings
	gitHubPersonal: GitHubPersonalSettings
	gitLab: GitLabSettings
	sentry: SentrySettings
	zendesk: ZendeskSettings
	intercom: IntercomSettings
	front: FrontSettings
	jira: JiraSettings
	notion: NotionSettings
	opsgenie: OpsgenieSettings
	pagerDuty: PagerDutySettings
	jiraPersonal: JiraPersonalSettings
}

"An integration with an external service."
type Integration implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The integration's type."
	service: String!
	"The organization that the integration is associated with."
	organization: Organization!
	"The team that the integration is associated with."
	team: Team
	"The user that added the integration."
	creator: User!
}

type IntegrationEdge {
	node: Integration!
	"Used in `before` and `after` args"
	cursor: String!
}

type IntegrationConnection {
	edges: [IntegrationEdge!]!
	nodes: [Integration!]!
	pageInfo: PageInfo!
}

"An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them."
type ExternalUser implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The external user's full name."
	name: String!
	"The external user's display name. Unique within each organization. Can match the display name of an actual user."
	displayName: String!
	"The external user's email address."
	email: String
	"An URL to the external user's avatar image."
	avatarUrl: String
	"Organization the external user belongs to."
	organization: Organization!
	"The last time the external user was seen interacting with Linear."
	lastSeen: DateTime
}

type ExternalUserEdge {
	node: ExternalUser!
	"Used in `before` and `after` args"
	cursor: String!
}

type ExternalUserConnection {
	edges: [ExternalUserEdge!]!
	nodes: [ExternalUser!]!
	pageInfo: PageInfo!
}

"A template object used for creating entities faster."
type Template implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The entity type this template is for."
	type: String!
	"The name of the template."
	name: String!
	"Template description."
	description: String
	"Template data."
	templateData: JSON!
	"The organization that the template is associated with. If null, the template is associated with a particular team."
	organization: Organization
	"The team that the template is associated with. If null, the template is global to the workspace."
	team: Team
	"The user who created the template."
	creator: User
	"The user who last updated the template."
	lastUpdatedBy: User
}

type TemplateEdge {
	node: Template!
	"Used in `before` and `after` args"
	cursor: String!
}

type TemplateConnection {
	edges: [TemplateEdge!]!
	nodes: [Template!]!
	pageInfo: PageInfo!
}

"An organization. Organizations are root-level objects that contain user accounts and teams."
type Organization implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The organization's name."
	name: String!
	"The organization's unique URL key."
	urlKey: String!
	"The organization's logo URL."
	logoUrl: String
	"Rolling 30-day total upload volume for the organization, in megabytes."
	periodUploadVolume: Float!
	"How git branches are formatted. If null, default formatting will be used."
	gitBranchFormat: String
	"Whether the Git integration linkback messages should be sent to private repositories."
	gitLinkbackMessagesEnabled: Boolean!
	"Whether the Git integration linkback messages should be sent to public repositories."
	gitPublicLinkbackMessagesEnabled: Boolean!
	"Whether the organization is using a roadmap."
	roadmapEnabled: Boolean!
	"The frequency at which to prompt for project updates."
	projectUpdatesReminderFrequency: ProjectUpdateReminderFrequency!
	"The day at which to prompt for project updates."
	projectUpdateRemindersDay: Day!
	"The hour at which to prompt for project updates."
	projectUpdateRemindersHour: Float!
	"The month at which the fiscal year starts. Defaults to January (0)."
	fiscalYearStartMonth: Float!
	"Whether SAML authentication is enabled for organization."
	samlEnabled: Boolean!
	"[INTERNAL] SAML settings."
	samlSettings: JSONObject
	"Whether SCIM provisioning is enabled for organization."
	scimEnabled: Boolean!
	"Allowed authentication providers, empty array means all are allowed."
	allowedAuthServices: [String!]!
	"The time at which deletion of the organization was requested."
	deletionRequestedAt: DateTime
	"The time at which the trial of the plus plan will end."
	trialEndsAt: DateTime
	"Previously used URL keys for the organization (last 3 are kept and redirected)."
	previousUrlKeys: [String!]!
	"Whether member users are allowed to send invites."
	allowMembersToInvite: Boolean
	"The feature release channel the organization belongs to."
	releaseChannel: ReleaseChannel!
	"Which day count to use for SLA calculations."
	slaDayCount: SLADayCountType!
	"Users associated with the organization."
	users(includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"Teams associated with the organization."
	teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"Integrations associated with the organization."
	integrations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationConnection!
	"The organization's subscription to a paid plan."
	subscription: PaidSubscription
	"Number of active users in the organization."
	userCount: Int!
	"Number of issues in the organization."
	createdIssueCount: Int!
	"Templates associated with the organization."
	templates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TemplateConnection!
	"Labels associated with the organization."
	labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
}

"The frequency at which to send project update reminders."
enum ProjectUpdateReminderFrequency {
	week
	twoWeeks
	month
	never
}

"The day of the week."
enum Day {
	Sunday
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
}

"Which day count to use for SLA calculations."
enum SLADayCountType {
	all
	onlyBusinessDays
}

"[INTERNAL] Join table between projects and initiatives."
type InitiativeToProject implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The project that the initiative is associated with."
	project: Project!
	"The initiative that the project is associated with."
	initiative: Initiative!
	"The sort order of the project within the initiative."
	sortOrder: String!
}

type InitiativeToProjectEdge {
	node: InitiativeToProject!
	"Used in `before` and `after` args"
	cursor: String!
}

type InitiativeToProjectConnection {
	edges: [InitiativeToProjectEdge!]!
	nodes: [InitiativeToProject!]!
	pageInfo: PageInfo!
}

"Join table between projects and roadmaps."
type RoadmapToProject implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The project that the roadmap is associated with."
	project: Project!
	"The roadmap that the project is associated with."
	roadmap: Roadmap!
	"The sort order of the project within the roadmap."
	sortOrder: String!
}

type RoadmapToProjectEdge {
	node: RoadmapToProject!
	"Used in `before` and `after` args"
	cursor: String!
}

type RoadmapToProjectConnection {
	edges: [RoadmapToProjectEdge!]!
	nodes: [RoadmapToProject!]!
	pageInfo: PageInfo!
}

"A roadmap for projects."
type Roadmap implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the roadmap."
	name: String!
	"The description of the roadmap."
	description: String
	"The organization of the roadmap."
	organization: Organization!
	"The user who created the roadmap."
	creator: User!
	"The user who owns the roadmap."
	owner: User!
	"The roadmap's unique URL slug."
	slugId: String!
	"The sort order of the roadmap within the organization."
	sortOrder: Float!
	"The roadmap's color."
	color: String
	"Projects associated with the roadmap."
	projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectConnection!
}

type RoadmapEdge {
	node: Roadmap!
	"Used in `before` and `after` args"
	cursor: String!
}

type RoadmapConnection {
	edges: [RoadmapEdge!]!
	nodes: [Roadmap!]!
	pageInfo: PageInfo!
}

"[INTERNAL] An initiative to group projects."
type Initiative implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the initiative."
	name: String!
	"The description of the initiative."
	description: String
	"The organization of the initiative."
	organization: Organization!
	"The user who created the initiative."
	creator: User!
	"The user who owns the initiative."
	owner: User!
	"The initiative's unique URL slug."
	slugId: String!
	"The sort order of the initiative within the organization."
	sortOrder: Float!
	"The initiative's color."
	color: String
	"The estimated completion date of the initiative."
	targetDate: TimelessDate
	"[INTERNAL] The resolution of the initiative's estimated completion date."
	targetDateResolution: DateResolutionType
	"Projects associated with the initiative."
	projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectConnection!
}

type InitiativeEdge {
	node: Initiative!
	"Used in `before` and `after` args"
	cursor: String!
}

type InitiativeConnection {
	edges: [InitiativeEdge!]!
	nodes: [Initiative!]!
	pageInfo: PageInfo!
}

"[ALPHA] A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a project to a roadmap for example."
type Facet implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The sort order of the facet."
	sortOrder: Float!
}

type FacetEdge {
	node: Facet!
	"Used in `before` and `after` args"
	cursor: String!
}

type FacetConnection {
	edges: [FacetEdge!]!
	nodes: [Facet!]!
	pageInfo: PageInfo!
}

"User favorites presented in the sidebar."
type Favorite implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The type of the favorite."
	type: String!
	"The parent folder of the favorite."
	parent: Favorite
	"The name of the folder. Only applies to favorites of type folder."
	folderName: String
	"The targeted tab of the project."
	projectTab: ProjectTab
	"The type of favorited predefined view."
	predefinedViewType: String
	"The owner of the favorite."
	owner: User!
	"The order of the item in the favorites list."
	sortOrder: Float!
	"Children of the favorite. Only applies to favorites of type folder."
	children(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FavoriteConnection!
	"The favorited issue."
	issue: Issue
	"The favorited project."
	project: Project
	"The favorited team of the project."
	projectTeam: Team
	"The favorited cycle."
	cycle: Cycle
	"The favorited custom view."
	customView: CustomView
	"The team of the favorited predefined view."
	predefinedViewTeam: Team
	"The favorited document."
	document: Document
	"The favorited roadmap."
	roadmap: Roadmap
	"The favorited label."
	label: IssueLabel
	"The favorited user."
	user: User
}

"Different tabs available inside a project."
enum ProjectTab {
	documents
	issues
	activity
}

type FavoriteEdge {
	node: Favorite!
	"Used in `before` and `after` args"
	cursor: String!
}

type FavoriteConnection {
	edges: [FavoriteEdge!]!
	nodes: [Favorite!]!
	pageInfo: PageInfo!
}

"A Git target branch for which there are automations (GitAutomationState)."
type GitAutomationTargetBranch implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The team to which this Git target branch automation belongs."
	team: Team!
	"The target branch pattern."
	branchPattern: String!
	"Whether the branch pattern is a regular expression."
	isRegex: Boolean!
	"Automation states associated with the target branch."
	automationStates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): GitAutomationStateConnection!
}

"A trigger that updates the issue status according to Git automations."
type GitAutomationState implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The associated workflow state."
	state: WorkflowState
	"The team to which this automation state belongs."
	team: Team!
	"The target branch associated to this automation state."
	targetBranch: GitAutomationTargetBranch
	"The event that triggers the automation."
	event: GitAutomationStates!
	"[DEPRECATED] The target branch, if null, the automation will be triggered on any branch."
	branchPattern: String @deprecated(reason: "Use targetBranch instead.")
}

"The various states of a pull/merge request."
enum GitAutomationStates {
	draft
	start
	review
	mergeable
	merge
}

type GitAutomationStateEdge {
	node: GitAutomationState!
	"Used in `before` and `after` args"
	cursor: String!
}

type GitAutomationStateConnection {
	edges: [GitAutomationStateEdge!]!
	nodes: [GitAutomationState!]!
	pageInfo: PageInfo!
}

"The configuration of all integrations for a project or a team."
type IntegrationsSettings implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Whether to send a Slack message when a new issue is created for the project or the team."
	slackIssueCreated: Boolean
	"Whether to send a Slack message when a comment is created on any of the project or team's issues."
	slackIssueNewComment: Boolean
	"Whether to send a Slack message when any of the project or team's issues change to completed or cancelled."
	slackIssueStatusChangedDone: Boolean
	"Whether to send a Slack message when any of the project or team's issues has a change in status."
	slackIssueStatusChangedAll: Boolean
	"Whether to send a Slack message when a project update is created."
	slackProjectUpdateCreated: Boolean
	"Whether to send a new project update to team Slack channels."
	slackProjectUpdateCreatedToTeam: Boolean
	"Whether to send a new project update to workspace Slack channel."
	slackProjectUpdateCreatedToWorkspace: Boolean
	"Whether to send a Slack message when a new issue is added to triage."
	slackIssueAddedToTriage: Boolean
	"Whether to send a Slack message when an SLA is at high risk."
	slackIssueSlaHighRisk: Boolean
	"Whether to send a Slack message when an SLA is breached."
	slackIssueSlaBreached: Boolean
	"Team which those settings apply to."
	team: Team
	"Project which those settings apply to."
	project: Project
}

type IntegrationsSettingsEdge {
	node: IntegrationsSettings!
	"Used in `before` and `after` args"
	cursor: String!
}

type IntegrationsSettingsConnection {
	edges: [IntegrationsSettingsEdge!]!
	nodes: [IntegrationsSettings!]!
	pageInfo: PageInfo!
}

"Labels that can be associated with issues."
type IssueLabel implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The label's name."
	name: String!
	"The label's description."
	description: String
	"The label's color as a HEX string."
	color: String!
	organization: Organization! @deprecated(reason: "Workspace labels are identified by their team being null.")
	"The team that the label is associated with. If null, the label is associated with the global workspace."
	team: Team
	"The user who created the label."
	creator: User
	"The parent label."
	parent: IssueLabel
	"Whether this label is considered to be a group."
	isGroup: Boolean!
	"Issues associated with the label."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Children of the label."
	children(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
}

type IssueLabelEdge {
	node: IssueLabel!
	"Used in `before` and `after` args"
	cursor: String!
}

type IssueLabelConnection {
	edges: [IssueLabelEdge!]!
	nodes: [IssueLabel!]!
	pageInfo: PageInfo!
}

"[Internal] A draft issue."
type IssueDraft implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The draft's title."
	title: String!
	"The draft's description in markdown format."
	description: String
	"The priority of the draft."
	priority: Float!
	"The estimate of the complexity of the draft."
	estimate: Float
	"The date at which the issue would be due."
	dueDate: TimelessDate
	"The team associated with the draft."
	teamId: String!
	"The cycle associated with the draft."
	cycleId: String
	"The project associated with the draft."
	projectId: String
	"The project milestone associated with the draft."
	projectMilestoneId: String
	"The user who created the draft."
	creator: User!
	"The user assigned to the draft."
	assigneeId: String
	"The workflow state associated with the draft."
	stateId: String!
	"The parent draft of the draft."
	parent: IssueDraft
	"The parent issue of the draft."
	parentIssue: Issue
	"The order of items in the sub-draft list. Only set if the draft has `parent` set."
	subIssueSortOrder: Float
	"Label for the priority."
	priorityLabel: String!
	"[Internal] The draft's description as a Prosemirror document."
	descriptionData: JSON
	"Serialized array of JSONs representing attachments."
	attachments: JSONObject!
}

"Issue relation history's payload."
type IssueRelationHistoryPayload {
	"The identifier of the related issue."
	identifier: String!
	"The type of the change."
	type: String!
}

"A record of changes to an issue."
type IssueHistory implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The issue that was changed."
	issue: Issue!
	"The user who made these changes. If null, possibly means that the change made by an integration."
	actor: User
	"The id of user who made these changes. If null, possibly means that the change made by an integration."
	actorId: String
	"Whether the issue's description was updated."
	updatedDescription: Boolean
	"What the title was changed from."
	fromTitle: String
	"What the title was changed to."
	toTitle: String
	"The user from whom the issue was re-assigned from."
	fromAssignee: User
	"The id of user from whom the issue was re-assigned from."
	fromAssigneeId: String
	"The user to whom the issue was assigned to."
	toAssignee: User
	"The id of user to whom the issue was assigned to."
	toAssigneeId: String
	"What the priority was changed from."
	fromPriority: Float
	"What the priority was changed to."
	toPriority: Float
	"The team from which the issue was moved from."
	fromTeam: Team
	"The id of team from which the issue was moved from."
	fromTeamId: String
	"The team to which the issue was moved to."
	toTeam: Team
	"The id of team to which the issue was moved to."
	toTeamId: String
	"The previous parent of the issue."
	fromParent: Issue
	"The id of previous parent of the issue."
	fromParentId: String
	"The new parent of the issue."
	toParent: Issue
	"The id of new parent of the issue."
	toParentId: String
	"The previous workflow state of the issue."
	fromState: WorkflowState
	"The id of previous workflow state of the issue."
	fromStateId: String
	"The new workflow state of the issue."
	toState: WorkflowState
	"The id of new workflow state of the issue."
	toStateId: String
	"The previous cycle of the issue."
	fromCycle: Cycle
	"The id of previous cycle of the issue."
	fromCycleId: String
	"The new cycle of the issue."
	toCycle: Cycle
	"The id of new cycle of the issue."
	toCycleId: String
	"The new project created from the issue."
	toConvertedProject: Project
	"The id of new project created from the issue."
	toConvertedProjectId: String
	"The previous project of the issue."
	fromProject: Project
	"The id of previous project of the issue."
	fromProjectId: String
	"The new project of the issue."
	toProject: Project
	"The id of new project of the issue."
	toProjectId: String
	"What the estimate was changed from."
	fromEstimate: Float
	"What the estimate was changed to."
	toEstimate: Float
	"Whether the issue is archived at the time of this history entry."
	archived: Boolean
	"Whether the issue was trashed or un-trashed."
	trashed: Boolean
	"The import record."
	issueImport: IssueImport
	"The linked attachment."
	attachment: Attachment
	"The id of linked attachment."
	attachmentId: String
	"ID's of labels that were added."
	addedLabelIds: [String!]
	"ID's of labels that were removed."
	removedLabelIds: [String!]
	"Changed issue relationships."
	relationChanges: [IssueRelationHistoryPayload!]
	"Whether the issue was auto-closed."
	autoClosed: Boolean
	"Whether the issue was auto-archived."
	autoArchived: Boolean
	"What the due date was changed from."
	fromDueDate: TimelessDate
	"What the due date was changed to."
	toDueDate: TimelessDate
	"[Internal] Serialized JSON representing changes for certain non-relational properties."
	changes: JSONObject
	"The bot that performed the action."
	botActor: ActorBot
	addedLabels: [IssueLabel!]
	removedLabels: [IssueLabel!]
}

type IssueHistoryEdge {
	node: IssueHistory!
	"Used in `before` and `after` args"
	cursor: String!
}

type IssueHistoryConnection {
	edges: [IssueHistoryEdge!]!
	nodes: [IssueHistory!]!
	pageInfo: PageInfo!
}

"An import job for data from an external service."
type IssueImport implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"New team's name in cases when teamId not set."
	teamName: String
	"The id for the user that started the job."
	creatorId: String!
	"The service from which data will be imported."
	service: String!
	"The status for the import job."
	status: String!
	"The data mapping configuration for the import job."
	mapping: JSONObject
	"User readable error message, if one has occurred during the import."
	error: String
	"Current step progress in % (0-100)."
	progress: Float
	"File URL for the uploaded CSV for the import, if there is one."
	csvFileUrl: String
	"Error code and metadata, if one has occurred during the import."
	errorMetadata: JSONObject
}

"A relation between two issues."
type IssueRelation implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The relationship of the issue with the related issue."
	type: String!
	"The issue whose relationship is being described."
	issue: Issue!
	"The related issue."
	relatedIssue: Issue!
}

type IssueRelationEdge {
	node: IssueRelation!
	"Used in `before` and `after` args"
	cursor: String!
}

type IssueRelationConnection {
	edges: [IssueRelationEdge!]!
	nodes: [IssueRelation!]!
	pageInfo: PageInfo!
}

"Request to install OAuth clients on organizations and the response to the request."
type OauthClientApproval implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The uuid of the OAuth client being requested for installation."
	oauthClientId: String!
	"The person who requested installing the OAuth client."
	requesterId: String!
	"The person who responded to the request to install the OAuth client."
	responderId: String
	"The status for the OAuth client approval request."
	status: OAuthClientApprovalStatus!
	"The scopes the app has requested."
	scopes: [String!]!
	"The reason the person wants to install this OAuth client."
	requestReason: String
	"The reason the request for the OAuth client approval was denied."
	denyReason: String
}

"The different requests statuses possible for an OAuth client approval request."
enum OAuthClientApprovalStatus {
	requested
	approved
	denied
}

"A basic entity."
interface Entity implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
}

"OAuth2 client application"
type OauthClient implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"OAuth application's client ID."
	clientId: String!
	"OAuth application's client name."
	name: String!
	"Information about the application."
	description: String
	"Name of the developer."
	developer: String!
	"Url of the developer."
	developerUrl: String!
	"Image of the application."
	imageUrl: String
	"OAuth application's client secret."
	clientSecret: String!
	"List of allowed redirect URIs for the application."
	redirectUris: [String!]!
	"Whether the OAuth application can be installed in other organizations."
	publicEnabled: Boolean!
	"The user who created the OAuth application."
	creator: User!
	"The organization that the OAuth application is associated with."
	organization: Organization!
	"The resource types to request when creating new webhooks."
	webhookResourceTypes: [String!]!
	"Webhook URL."
	webhookUrl: String
	"Webhook secret token for verifying the origin on the recipient side."
	webhookSecret: String
}

type OauthClientEdge {
	node: OauthClient!
	"Used in `before` and `after` args"
	cursor: String!
}

type OauthClientConnection {
	edges: [OauthClientEdge!]!
	nodes: [OauthClient!]!
	pageInfo: PageInfo!
}

"Defines the use of a domain by an organization."
type OrganizationDomain implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Domain name."
	name: String!
	"Is this domain verified."
	verified: Boolean!
	"E-mail used to verify this domain."
	verificationEmail: String
	"The user who added the domain."
	creator: User
	"What type of auth is the domain used for."
	authType: OrganizationDomainAuthType!
	"Whether the domains was claimed by the organization through DNS verification."
	claimed: Boolean
}

"An invitation to the organization that has been sent via email."
type OrganizationInvite implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The invitees email address."
	email: String!
	"The user role that the invitee will receive upon accepting the invite."
	role: UserRoleType!
	"The invite was sent to external address."
	external: Boolean!
	"The time at which the invite was accepted. Null, if the invite hasn't been accepted."
	acceptedAt: DateTime
	"The time at which the invite will be expiring. Null, if the invite shouldn't expire."
	expiresAt: DateTime
	"Extra metadata associated with the organization invite."
	metadata: JSONObject!
	"The user who created the invitation."
	inviter: User!
	"The user who has accepted the invite. Null, if the invite hasn't been accepted."
	invitee: User
	"The organization that the invite is associated with."
	organization: Organization!
}

type OrganizationInviteEdge {
	node: OrganizationInvite!
	"Used in `before` and `after` args"
	cursor: String!
}

type OrganizationInviteConnection {
	edges: [OrganizationInviteEdge!]!
	nodes: [OrganizationInvite!]!
	pageInfo: PageInfo!
}

"A milestone for a project."
type ProjectMilestone implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the project milestone."
	name: String!
	"The planned completion date of the milestone."
	targetDate: TimelessDate
	"The project of the milestone."
	project: Project!
	"The order of the milestone in relation to other milestones within a project."
	sortOrder: Float!
	"The project milestone's description in markdown format."
	description: String
	"[Internal] The project milestone's description as a Prosemirror document."
	descriptionData: JSON @deprecated(reason: "Use `descriptionState` instead.")
	"[Internal] The project milestone's description as YJS state."
	descriptionState: String
	"Issues associated with the project milestone."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
}

type ProjectMilestoneEdge {
	node: ProjectMilestone!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectMilestoneConnection {
	edges: [ProjectMilestoneEdge!]!
	nodes: [ProjectMilestone!]!
	pageInfo: PageInfo!
}

"An external link for a project."
type ProjectLink implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The link's URL."
	url: String!
	"The link's label."
	label: String!
	"The order of the item in the project resources list."
	sortOrder: Float!
	"The user who created the link."
	creator: User!
	"The project that the link is associated with."
	project: Project!
}

type ProjectLinkEdge {
	node: ProjectLink!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectLinkConnection {
	edges: [ProjectLinkEdge!]!
	nodes: [ProjectLink!]!
	pageInfo: PageInfo!
}

"[ALPHA] A project status."
type ProjectStatus implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the status."
	name: String!
	"The UI color of the status as a HEX string."
	color: String!
	"Description of the status."
	description: String
	"The position of the status in the workspace's project flow."
	position: Float!
	"The type of the project status."
	type: ProjectStatusType!
	"Whether or not a project can be in this status indefinitely."
	indefinite: Boolean!
}

"A type of project status."
enum ProjectStatusType {
	backlog
	planned
	started
	paused
	completed
	canceled
}

type ProjectStatusEdge {
	node: ProjectStatus!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectStatusConnection {
	edges: [ProjectStatusEdge!]!
	nodes: [ProjectStatus!]!
	pageInfo: PageInfo!
}

"Holds information about when a user has interacted with a project update."
type ProjectUpdateInteraction implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that has interacted with the project update."
	user: User!
	"The project update that has been interacted with."
	projectUpdate: ProjectUpdate!
	"The time at which the user read the project update."
	readAt: DateTime!
}

type ProjectUpdateInteractionEdge {
	node: ProjectUpdateInteraction!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectUpdateInteractionConnection {
	edges: [ProjectUpdateInteractionEdge!]!
	nodes: [ProjectUpdateInteraction!]!
	pageInfo: PageInfo!
}

"A user's web browser push notification subscription."
type PushSubscription implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
}

type PushSubscriptionEdge {
	node: PushSubscription!
	"Used in `before` and `after` args"
	cursor: String!
}

type PushSubscriptionConnection {
	edges: [PushSubscriptionEdge!]!
	nodes: [PushSubscription!]!
	pageInfo: PageInfo!
}

"The paid subscription of an organization."
type PaidSubscription implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The subscription type."
	type: String!
	"The number of seats in the subscription."
	seats: Float!
	"The minimum number of seats that will be billed in the subscription."
	seatsMinimum: Float
	"The maximum number of seats that will be billed in the subscription."
	seatsMaximum: Float
	"The creator of the subscription."
	creator: User
	"The organization that the subscription is associated with."
	organization: Organization!
	"The collection method for this subscription, either automatically charged or invoiced."
	collectionMethod: String
	"The date the subscription was canceled, if any."
	canceledAt: DateTime
	"The subscription type of a pending change. Null if no change pending."
	pendingChangeType: String
	"The date the subscription will be billed next."
	nextBillingAt: DateTime
}

"An organizational unit that contains issues."
type Team implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The team's name."
	name: String!
	"The team's unique key. The key is used in URLs."
	key: String!
	"The team's description."
	description: String
	"The icon of the team."
	icon: String
	"The team's color."
	color: String
	"The organization that the team is associated with."
	organization: Organization!
	"Whether the team uses cycles."
	cyclesEnabled: Boolean!
	"The day of the week that a new cycle starts."
	cycleStartDay: Float!
	"The duration of a cycle in weeks."
	cycleDuration: Float!
	"The cooldown time after each cycle in weeks."
	cycleCooldownTime: Float!
	"Auto assign started issues to current cycle."
	cycleIssueAutoAssignStarted: Boolean!
	"Auto assign completed issues to current cycle."
	cycleIssueAutoAssignCompleted: Boolean!
	"Auto assign issues to current cycle if in active status."
	cycleLockToActive: Boolean!
	"How many upcoming cycles to create."
	upcomingCycleCount: Float!
	"The timezone of the team. Defaults to \"America/Los_Angeles\""
	timezone: String!
	"Unique hash for the team to be used in invite URLs."
	inviteHash: String!
	"The issue estimation type to use. Must be one of \"notUsed\", \"exponential\", \"fibonacci\", \"linear\", \"tShirt\"."
	issueEstimationType: String!
	"Whether issues without priority should be sorted first."
	issueOrderingNoPriorityFirst: Boolean!
	"Whether to allow zeros in issues estimates."
	issueEstimationAllowZero: Boolean!
	"Where to move issues when changing state."
	setIssueSortOrderOnStateChange: String!
	"Whether to add additional points to the estimate scale."
	issueEstimationExtended: Boolean!
	"What to use as an default estimate for unestimated issues."
	defaultIssueEstimate: Float!
	"Whether triage mode is enabled for the team or not."
	triageEnabled: Boolean!
	"Whether an issue needs to have a priority set before leaving triage."
	requirePriorityToLeaveTriage: Boolean!
	"The default workflow state into which issues are set when they are opened by team members."
	defaultIssueState: WorkflowState
	"The default template to use for new issues created by members of the team."
	defaultTemplateForMembers: Template
	"The id of the default template to use for new issues created by members of the team."
	defaultTemplateForMembersId: String @deprecated(reason: "Use defaultTemplateForMembers instead")
	"The default template to use for new issues created by non-members of the team."
	defaultTemplateForNonMembers: Template
	"The id of the default template to use for new issues created by non-members of the team."
	defaultTemplateForNonMembersId: String @deprecated(reason: "Use defaultTemplateForNonMembers instead")
	"The default template to use for new projects created for the team."
	defaultProjectTemplate: Template
	"The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled."
	triageIssueState: WorkflowState
	"Whether the team is private or not."
	private: Boolean!
	"The workflow state into which issues are moved when a PR has been opened as draft."
	draftWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")
	"The workflow state into which issues are moved when a PR has been opened."
	startWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")
	"The workflow state into which issues are moved when a review has been requested for the PR."
	reviewWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")
	"The workflow state into which issues are moved when a PR is ready to be merged."
	mergeableWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")
	"The workflow state into which issues are moved when a PR has been merged."
	mergeWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")
	"Whether to group recent issue history entries."
	groupIssueHistory: Boolean!
	"Whether to send new issue notifications to Slack."
	slackNewIssue: Boolean!
	"Whether to send new issue comment notifications to Slack."
	slackIssueComments: Boolean!
	"Whether to send new issue status updates to Slack."
	slackIssueStatuses: Boolean!
	"Period after which issues are automatically closed in months. Null/undefined means disabled."
	autoClosePeriod: Float
	"The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state."
	autoCloseStateId: String
	"Period after which automatically closed and completed issues are automatically archived in months."
	autoArchivePeriod: Float!
	"The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state."
	markedAsDuplicateWorkflowState: WorkflowState
	"[INTERNAL] Whether new users should join this team by default."
	joinByDefault: Boolean
	"Calendar feed URL (iCal) for cycles."
	cycleCalenderUrl: String!
	"Issues associated with the team."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Number of issues in the team."
	issueCount(includeArchived: Boolean = false): Int!
	"Cycles associated with the team."
	cycles(filter: CycleFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CycleConnection!
	"Team's currently active cycle."
	activeCycle: Cycle
	"Team's triage responsibility."
	triageResponsibility: TriageResponsibility
	"Users who are members of this team."
	members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"Memberships associated with the team. For easier access of the same data, use `members` query."
	memberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
	"Projects associated with the team."
	projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectConnection!
	"The states that define the workflow associated with the team."
	states(filter: WorkflowStateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WorkflowStateConnection!
	"The Git automation states for the team."
	gitAutomationStates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): GitAutomationStateConnection!
	"Templates associated with the team."
	templates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TemplateConnection!
	"Labels associated with the team."
	labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
	"Webhooks associated with the team."
	webhooks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WebhookConnection!
	"Settings for all integrations associated with that team."
	integrationsSettings: IntegrationsSettings
	"[DEPRECATED] Whether to move issues to bottom of the column when changing state."
	issueSortOrderDefaultToBottom: Boolean! @deprecated(reason: "Use setIssueSortOrderOnStateChange instead.")
}

type TeamEdge {
	node: Team!
	"Used in `before` and `after` args"
	cursor: String!
}

type TeamConnection {
	edges: [TeamEdge!]!
	nodes: [Team!]!
	pageInfo: PageInfo!
}

"Defines the membership of a user to a team."
type TeamMembership implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that the membership is associated with."
	user: User!
	"The team that the membership is associated with."
	team: Team!
	"Whether the user is the owner of the team."
	owner: Boolean
	"The order of the item in the users team list."
	sortOrder: Float!
}

type TeamMembershipEdge {
	node: TeamMembership!
	"Used in `before` and `after` args"
	cursor: String!
}

type TeamMembershipConnection {
	edges: [TeamMembershipEdge!]!
	nodes: [TeamMembership!]!
	pageInfo: PageInfo!
}

type TimeScheduleEntry {
	"The start date of the schedule in ISO 8601 date-time format."
	startsAt: DateTime!
	"The end date of the schedule in ISO 8601 date-time format."
	endsAt: DateTime!
	"The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference."
	userId: String
	"The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id."
	userEmail: String
}

"A time schedule."
type TimeSchedule implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the schedule."
	name: String!
	"The schedule entries."
	entries: [TimeScheduleEntry!]!
	"The identifier of the external schedule."
	externalId: String
	"The URL to the external schedule."
	externalUrl: String
	"The organization of the schedule."
	organization: Organization!
	"The identifier of the Linear integration populating the schedule."
	integration: Integration
}

type TimeScheduleEdge {
	node: TimeSchedule!
	"Used in `before` and `after` args"
	cursor: String!
}

type TimeScheduleConnection {
	edges: [TimeScheduleEdge!]!
	nodes: [TimeSchedule!]!
	pageInfo: PageInfo!
}

type TriageResponsibilityManualSelection {
	"The set of users responsible for triage."
	userIds: [String!]!
	"[INTERNAL] The index of the current userId used for the assign action when having more than one user."
	assignmentIndex: Int
}

"A team's triage responsibility."
type TriageResponsibility implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The action to take when an issue is added to triage."
	action: TriageResponsibilityAction!
	"Set of users used for triage responsibility."
	manualSelection: TriageResponsibilityManualSelection
	"The team to which the triage responsibility belongs to."
	team: Team!
	"The time schedule used for scheduling."
	timeSchedule: TimeSchedule
	"The user currently responsible for triage."
	currentUser: User
}

"Which action should be taken after an issue is added to triage."
enum TriageResponsibilityAction {
	assign
	notify
}

type TriageResponsibilityEdge {
	node: TriageResponsibility!
	"Used in `before` and `after` args"
	cursor: String!
}

type TriageResponsibilityConnection {
	edges: [TriageResponsibilityEdge!]!
	nodes: [TriageResponsibility!]!
	pageInfo: PageInfo!
}

"The settings of a user as a JSON object."
type UserSettings implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The notification channel settings the user has selected."
	notificationPreferences: JSONObject!
	"The email types the user has unsubscribed from."
	unsubscribedFrom: [String!]! @deprecated(reason: "Use individual subscription fields instead. This field's value is now outdated.")
	"The user associated with these settings."
	user: User!
	"Hash for the user to be used in calendar URLs."
	calendarHash: String
	"Whether this user is subscribed to changelog email or not."
	subscribedToChangelog: Boolean!
	"Whether this user is subscribed to DPA emails or not."
	subscribedToDPA: Boolean!
	"Whether this user is subscribed to invite accepted emails or not."
	subscribedToInviteAccepted: Boolean!
	"Whether this user is subscribed to privacy and legal update emails or not."
	subscribedToPrivacyLegalUpdates: Boolean!
	"Whether this user is subscribed to unread notifications reminder emails or not."
	subscribedToUnreadNotificationsReminder: Boolean!
	"Whether to show full user names instead of display names."
	showFullUserNames: Boolean!
}

"View preferences."
type ViewPreferences implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The view preference type."
	type: String!
	"The view type."
	viewType: String!
}

"A webhook used to send HTTP notifications over data updates."
type Webhook implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Webhook label."
	label: String
	"Webhook URL."
	url: String
	"Whether the Webhook is enabled."
	enabled: Boolean!
	"The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization."
	team: Team
	"Whether the Webhook is enabled for all public teams, including teams created after the webhook was created."
	allPublicTeams: Boolean!
	"The user who created the webhook."
	creator: User
	"Secret token for verifying the origin on the recipient side."
	secret: String
	"The resource types this webhook is subscribed to."
	resourceTypes: [String!]!
}

type WebhookEdge {
	node: Webhook!
	"Used in `before` and `after` args"
	cursor: String!
}

type WebhookConnection {
	edges: [WebhookEdge!]!
	nodes: [Webhook!]!
	pageInfo: PageInfo!
}

type WorkflowCronJobDefinition implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the workflow cron job."
	name: String!
	"The description of the workflow cron job."
	description: String
	enabled: Boolean!
	"The team associated with the workflow cron job."
	team: Team!
	"The user who created the workflow cron job."
	creator: User!
	"Cron schedule which is used to execute the workflow cron job."
	schedule: JSONObject!
	"An array of activities that will be executed as part of the workflow cron job."
	activities: JSONObject!
	"The sort order of the workflow cron job definition within its siblings."
	sortOrder: String!
}

type WorkflowCronJobDefinitionEdge {
	node: WorkflowCronJobDefinition!
	"Used in `before` and `after` args"
	cursor: String!
}

type WorkflowCronJobDefinitionConnection {
	edges: [WorkflowCronJobDefinitionEdge!]!
	nodes: [WorkflowCronJobDefinition!]!
	pageInfo: PageInfo!
}

type WorkflowDefinition implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The name of the workflow."
	name: String!
	"The name of the group that the workflow belongs to."
	groupName: String
	"The description of the workflow."
	description: String
	"The type of the workflow."
	type: WorkflowType!
	"The type of the event that triggers off the workflow."
	trigger: WorkflowTrigger!
	"The object type (e.g. Issue) that triggers this workflow."
	triggerType: WorkflowTriggerType!
	"The conditions that need to be match for the workflow to be triggered."
	conditions: JSONObject!
	enabled: Boolean!
	"The team associated with the workflow. If not set, the workflow is associated with the entire organization."
	team: Team
	"The user who created the workflow."
	creator: User!
	"An array of activities that will be executed as part of the workflow."
	activities: JSONObject!
	"The sort order of the workflow definition within its siblings."
	sortOrder: String!
	"The contextual label view associated with the workflow."
	label: IssueLabel
	"The contextual cycle view associated with the workflow."
	cycle: Cycle
	"The contextual user view associated with the workflow."
	user: User
	"The contextual project view associated with the workflow."
	project: Project
	"The context custom view associated with the workflow."
	customView: CustomView
	"The type of view to which this workflow's context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which this workflow's context is associated with."
	userContextViewType: UserContextViewType
}

enum WorkflowType {
	sla
	custom
	viewSubscription
}

enum WorkflowTrigger {
	entityCreated
	entityUpdated
	entityCreatedOrUpdated
	entityRemoved
	entityUnarchived
}

enum WorkflowTriggerType {
	issue
	project
}

enum ContextViewType {
	activeIssues
	activeCycle
	upcomingCycle
	backlog
	triage
}

enum UserContextViewType {
	assigned
}

type WorkflowDefinitionEdge {
	node: WorkflowDefinition!
	"Used in `before` and `after` args"
	cursor: String!
}

type WorkflowDefinitionConnection {
	edges: [WorkflowDefinitionEdge!]!
	nodes: [WorkflowDefinition!]!
	pageInfo: PageInfo!
}

"A state in a team workflow."
type WorkflowState implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The state's name."
	name: String!
	"The state's UI color as a HEX string."
	color: String!
	"Description of the state."
	description: String
	"The position of the state in the team flow."
	position: Float!
	"The type of the state. One of \"triage\", \"backlog\", \"unstarted\", \"started\", \"completed\", \"canceled\"."
	type: String!
	"The team to which this state belongs to."
	team: Team!
	"Issues belonging in this state."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
}

type WorkflowStateEdge {
	node: WorkflowState!
	"Used in `before` and `after` args"
	cursor: String!
}

type WorkflowStateConnection {
	edges: [WorkflowStateEdge!]!
	nodes: [WorkflowState!]!
	pageInfo: PageInfo!
}

type NotificationSubscriptionEdge {
	node: NotificationSubscription!
	"Used in `before` and `after` args"
	cursor: String!
}

type NotificationSubscriptionConnection {
	edges: [NotificationSubscriptionEdge!]!
	nodes: [NotificationSubscription!]!
	pageInfo: PageInfo!
}

type SynchronizedPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
}

"A generic payload return from entity deletion mutations."
type DeletePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The identifier of the deleted entity."
	entityId: String!
}

type IssuePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The issue that was created or updated."
	issue: Issue
	"Whether the operation was successful."
	success: Boolean!
}

type IssueBatchPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The issues that were updated."
	issues: [Issue!]!
	"Whether the operation was successful."
	success: Boolean!
}

type AuthSuccessPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type AuthApiKeyPayload {
	"Whether the operation was successful."
	success: Boolean!
	"The auth API key that was created."
	authApiKey: AuthApiKey!
}

type ApiKeyPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The API key that was created."
	apiKey: ApiKey!
	"Whether the operation was successful."
	success: Boolean!
}

"Public information of the OAuth application."
type Application {
	"OAuth application's ID."
	id: String!
	"OAuth application's client ID."
	clientId: String!
	"Application name."
	name: String!
	"Information about the application."
	description: String
	"Name of the developer."
	developer: String!
	"Url of the developer (homepage or docs)."
	developerUrl: String!
	"Image of the application."
	imageUrl: String
}

"Public information of the OAuth application, plus whether the application has been authorized for the given scopes."
type UserAuthorizedApplication {
	"OAuth application's ID."
	id: String!
	"OAuth application's client ID."
	clientId: String!
	"Application name."
	name: String!
	"Information about the application."
	description: String
	"Name of the developer."
	developer: String!
	"Url of the developer (homepage or docs)."
	developerUrl: String!
	"Image of the application."
	imageUrl: String
	"Whether the user has authorized the application for the given scopes."
	isAuthorized: Boolean!
	"Whether the application was created by Linear."
	createdByLinear: Boolean!
	"Whether or not webhooks are enabled for the application."
	webhooksEnabled: Boolean!
	"Error associated with the application needing to be requested for approval in the workspace."
	approvalErrorCode: String
}

"[INTERNAL] Public information of the OAuth application, plus the authorized scopes for a given user."
type AuthorizedApplication {
	"Application name."
	name: String!
	"Image of the application."
	imageUrl: String
	"Scopes that are authorized for this application for a given user."
	scope: [String!]!
	"OAuth application's ID."
	appId: String!
	"OAuth application's client ID."
	clientId: String!
	"Whether or not webhooks are enabled for the application."
	webhooksEnabled: Boolean!
}

"[INTERNAL] Public information of the OAuth application, plus the userIds and scopes for those users."
type WorkspaceAuthorizedApplication {
	"Application name."
	name: String!
	"Image of the application."
	imageUrl: String
	"Scopes that are authorized for this application for a given user."
	scope: [String!]!
	"OAuth application's ID."
	appId: String!
	"OAuth application's client ID."
	clientId: String!
	"Whether or not webhooks are enabled for the application."
	webhooksEnabled: Boolean!
	"Total number of members that authorized the application."
	totalMembers: Float!
	"UserIds and membership dates of everyone who has authorized the application with the set of scopes."
	memberships: [AuthMembership!]!
}

type AttachmentPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The issue attachment that was created."
	attachment: Attachment!
	"Whether the operation was successful."
	success: Boolean!
}

type FrontAttachmentPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
}

type AttachmentSourcesPayload {
	"A unique list of all source types used in this workspace."
	sources: JSONObject!
}

"A generic payload return from entity archive mutations."
type AttachmentArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Attachment
}

type AuditEntryEdge {
	node: AuditEntry!
	"Used in `before` and `after` args"
	cursor: String!
}

type AuditEntryConnection {
	edges: [AuditEntryEdge!]!
	nodes: [AuditEntry!]!
	pageInfo: PageInfo!
}

type AuditEntryType {
	"The audit entry type."
	type: String!
	"Description of the audit entry type."
	description: String!
}

type SsoUrlFromEmailResponse {
	"Whether the operation was successful."
	success: Boolean!
	"SAML SSO sign-in URL."
	samlSsoUrl: String!
}

type AuthResolverResponse {
	"User account ID."
	id: String!
	"Email for the authenticated account."
	email: String!
	"Should the signup flow allow access for the domain."
	allowDomainAccess: Boolean
	"List of active users that belong to the user account."
	users: [AuthUser!]!
	"List of organizations allowing this user account to join automatically."
	availableOrganizations: [AuthOrganization!]
	"List of organization available to this user account but locked due to the current auth method."
	lockedOrganizations: [AuthOrganization!]
	"ID of the organization last accessed by the user."
	lastUsedOrganizationId: String
	"Application token."
	token: String @deprecated(reason: "Deprecated and not used anymore. Never populated.")
}

type LogoutResponse {
	"Whether the operation was successful."
	success: Boolean!
}

type CreateOrJoinOrganizationResponse {
	organization: AuthOrganization!
	user: AuthUser!
}

"Authentication session information."
type AuthenticationSessionResponse {
	id: String!
	"Type of application used to authenticate."
	type: AuthenticationSessionType!
	"IP address."
	ip: String
	"Location country name."
	locationCountry: String
	"Location country code."
	locationCountryCode: String
	"Country codes of all seen locations."
	countryCodes: [String!]!
	"Location city name."
	locationCity: String
	"Session's user-agent."
	userAgent: String
	"Used web browser."
	browserType: String
	"When was the session last seen"
	lastActiveAt: DateTime
	"Date when the session was created."
	createdAt: DateTime!
	"Date when the session was last updated."
	updatedAt: DateTime!
	"Human readable location"
	location: String
	"Operating system used for the session"
	operatingSystem: String
	"Client used for the session"
	client: String
	"Name of the session, derived from the client and operating system"
	name: String!
	"Identifies the session used to make the request."
	isCurrentSession: Boolean!
}

type OrganizationRegionResponse {
	"Whether the operation was successful."
	success: Boolean!
	"The region for the organization."
	region: String
}

type EmailUserAccountAuthChallengeResponse {
	"Whether the operation was successful."
	success: Boolean!
	"Supported challenge for this user account. Can be either verificationCode or password."
	authType: String!
}

type CommentPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The comment that was created or updated."
	comment: Comment!
	"Whether the operation was successful."
	success: Boolean!
}

type ContactPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type CustomViewPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The custom view that was created or updated."
	customView: CustomView!
	"Whether the operation was successful."
	success: Boolean!
}

type CustomViewSuggestionPayload {
	"The suggested view name."
	name: String
	"The suggested view description."
	description: String
	"The suggested view icon."
	icon: String
}

type CustomViewHasSubscribersPayload {
	"Whether the custom view has subscribers."
	hasSubscribers: Boolean!
}

type CyclePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The Cycle that was created or updated."
	cycle: Cycle
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type CycleArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Cycle
}

type DocumentContentHistoryType {
	"The UUID of the document content history entry."
	id: String!
	"The date when the document content history entry was created."
	createdAt: DateTime!
	"The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same."
	contentDataSnapshotAt: DateTime!
	"[Internal] The document content as Prosemirror document."
	contentData: JSON!
	"The ID of the author of the change."
	actorIds: [String!]
}

type DocumentContentHistoryPayload {
	"The document content history entries."
	history: [DocumentContentHistoryType!]
	"Whether the operation was successful."
	success: Boolean!
}

type DocumentPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The document that was created or updated."
	document: Document!
	"Whether the operation was successful."
	success: Boolean!
}

type EmailIntakeAddressPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The email address that was created or updated."
	emailIntakeAddress: EmailIntakeAddress!
	"Whether the operation was successful."
	success: Boolean!
}

type EmailUnsubscribePayload {
	"Whether the operation was successful."
	success: Boolean!
}

type EmojiPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The emoji that was created."
	emoji: Emoji!
	"Whether the operation was successful."
	success: Boolean!
}

"[INTERNAL] The result of a initiativeToProject mutation."
type InitiativeToProjectPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The initiativeToProject that was created or updated."
	initiativeToProject: InitiativeToProject!
	"Whether the operation was successful."
	success: Boolean!
}

"[Internal] The payload returned by the initiative mutations."
type InitiativePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The initiative that was created or updated."
	initiative: Initiative!
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type InitiativeArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Initiative
}

type FavoritePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The object that was added as a favorite."
	favorite: Favorite!
	"Whether the operation was successful."
	success: Boolean!
}

type UploadFileHeader {
	"Upload file header key."
	key: String!
	"Upload file header value."
	value: String!
}

"Object representing Google Cloud upload policy, plus additional data."
type UploadFile {
	"The filename."
	filename: String!
	"The content type."
	contentType: String!
	"The size of the uploaded file."
	size: Int!
	"The signed URL the for the uploaded file. (assigned automatically)."
	uploadUrl: String!
	"The asset URL for the uploaded file. (assigned automatically)."
	assetUrl: String!
	metaData: JSONObject
	headers: [UploadFileHeader!]!
}

type UploadPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Object describing the file to be uploaded."
	uploadFile: UploadFile
	"Whether the operation was successful."
	success: Boolean!
}

type ImageUploadFromUrlPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The URL containing the image."
	url: String
	"Whether the operation was successful."
	success: Boolean!
}

type GitAutomationStatePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The automation state that was created or updated."
	gitAutomationState: GitAutomationState!
	"Whether the operation was successful."
	success: Boolean!
}

type GitAutomationTargetBranchPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The Git target branch automation that was created or updated."
	targetBranch: GitAutomationTargetBranch!
	"Whether the operation was successful."
	success: Boolean!
}

type IntegrationRequestPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type IntegrationPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The integration that was created or updated."
	integration: Integration
	"Whether the operation was successful."
	success: Boolean!
}

type GitHubCommitIntegrationPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The integration that was created or updated."
	integration: Integration
	"Whether the operation was successful."
	success: Boolean!
	"The webhook secret to provide to GitHub."
	webhookSecret: String!
}

type AsksChannelConnectPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The integration that was created or updated."
	integration: Integration
	"Whether the operation was successful."
	success: Boolean!
	"The new Asks Slack channel mapping for the connected channel."
	mapping: SlackChannelNameMapping!
	"Whether the bot needs to be manually added to the channel."
	addBot: Boolean!
}

type SlackChannelConnectPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The integration that was created or updated."
	integration: Integration
	"Whether the operation was successful."
	success: Boolean!
	"Whether the bot needs to be manually added to the channel."
	addBot: Boolean!
	"Whether it's recommended to connect main Slack integration."
	nudgeToConnectMainSlackIntegration: Boolean
	"Whether it's recommended to update main Slack integration."
	nudgeToUpdateMainSlackIntegration: Boolean
}

type IntegrationHasScopesPayload {
	"Whether the integration has the required scopes."
	hasAllScopes: Boolean!
	"The missing scopes."
	missingScopes: [String!]
}

type IntegrationsSettingsPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The settings that were created or updated."
	integrationsSettings: IntegrationsSettings!
	"Whether the operation was successful."
	success: Boolean!
}

type IntegrationTemplatePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The IntegrationTemplate that was created or updated."
	integrationTemplate: IntegrationTemplate!
	"Whether the operation was successful."
	success: Boolean!
}

type IssueImportPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The import job that was created or updated."
	issueImport: IssueImport
	"Whether the operation was successful."
	success: Boolean!
}

type IssueImportDeletePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The import job that was deleted."
	issueImport: IssueImport
	"Whether the operation was successful."
	success: Boolean!
}

type IssueImportCheckPayload {
	"Whether the operation was successful."
	success: Boolean!
}

"Relevant information for the GitHub repository."
type GithubRepo {
	"The id of the GitHub repository."
	id: String!
	"The name of the GitHub repository."
	name: String!
}

"Relevant information for the GitHub organization."
type GithubOrg {
	"GitHub organization id."
	id: String!
	"The login for the GitHub organization."
	login: String!
	"Repositories that the organization owns."
	repositories: [GithubRepo!]!
	"Whether or not this org is the user's personal repositories."
	isPersonal: Boolean
}

"GitHub OAuth token, plus information about the organizations the user is a member of."
type GithubOAuthTokenPayload {
	"The OAuth token if the operation to fetch it was successful."
	token: String
	"A list of the GitHub organizations the user is a member of with attached repositories."
	organizations: [GithubOrg!]
}

type IssueLabelPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The label that was created or updated."
	issueLabel: IssueLabel!
	"Whether the operation was successful."
	success: Boolean!
}

type IssueRelationPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The issue relation that was created or updated."
	issueRelation: IssueRelation!
	"Whether the operation was successful."
	success: Boolean!
}

type IssuePriorityValue {
	"Priority's number value."
	priority: Int!
	"Priority's label."
	label: String!
}

type IssueFilterSuggestionPayload {
	"The json filter that is suggested."
	filter: JSONObject
}

"A generic payload return from entity archive mutations."
type IssueArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Issue
}

type NotificationPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The notification that was created or updated."
	notification: Notification!
	"Whether the operation was successful."
	success: Boolean!
}

type NotificationBatchActionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The notifications that were updated."
	notifications: [Notification!]!
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type NotificationArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Notification
}

type NotificationEdge {
	node: Notification!
	"Used in `before` and `after` args"
	cursor: String!
}

type NotificationConnection {
	edges: [NotificationEdge!]!
	nodes: [Notification!]!
	pageInfo: PageInfo!
}

type NotificationSubscriptionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The notification subscription that was created or updated."
	notificationSubscription: NotificationSubscription!
	"Whether the operation was successful."
	success: Boolean!
}

"[INTERNAL] Organization domain operation response."
type OrganizationDomainPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The organization domain that was created or updated."
	organizationDomain: OrganizationDomain!
	"Whether the operation was successful."
	success: Boolean!
}

"[INTERNAL] Organization domain operation response."
type OrganizationDomainSimplePayload {
	"Whether the operation was successful."
	success: Boolean!
}

"[INTERNAL] Domain claim request response."
type OrganizationDomainClaimPayload {
	"String to put into DNS for verification."
	verificationString: String!
}

type OrganizationInviteLinkDetailsPayload {
	"Name of the workspace the invite link is for."
	organizationName: String
	"ID of the workspace the invite link is for."
	organizationId: String
	"URL of the workspace logo the invite link is for."
	organizationLogoUrl: String
	"URL key of the workspace the invite link is for."
	organizationUrlKey: String
	"Region of the workspace the invite link is for."
	organizationRegion: String
	"Allowed authentication providers, empty array means all are allowed."
	allowedAuthServices: [String!]!
}

type OrganizationInviteFullDetailsPayload {
	"The status of the invite."
	status: OrganizationInviteStatus!
	"The name of the inviter."
	inviter: String!
	"The email of the invitee."
	email: String!
	"What user role the invite should grant."
	role: UserRoleType!
	"When the invite was created."
	createdAt: DateTime!
	"Name of the workspace the invite is for."
	organizationName: String!
	"ID of the workspace the invite is for."
	organizationId: String!
	"URL of the workspace logo the invite is for."
	organizationLogoUrl: String
	"Whether the invite has already been accepted."
	accepted: Boolean!
	"Whether the invite has expired."
	expired: Boolean!
	"Allowed authentication providers, empty array means all are allowed."
	allowedAuthServices: [String!]!
}

"The different statuses possible for an organization invite."
enum OrganizationInviteStatus {
	pending
	accepted
	expired
}

type OrganizationAcceptedOrExpiredInviteDetailsPayload {
	"The status of the invite."
	status: OrganizationInviteStatus!
}

type OrganizationInvitePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The organization invite that was created or updated."
	organizationInvite: OrganizationInvite!
	"Whether the operation was successful."
	success: Boolean!
}

type OrganizationPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The organization that was created or updated."
	organization: Organization
	"Whether the operation was successful."
	success: Boolean!
}

type OrganizationDeletePayload {
	"Whether the operation was successful."
	success: Boolean!
}

type OrganizationCancelDeletePayload {
	"Whether the operation was successful."
	success: Boolean!
}

type OrganizationStartPlusTrialPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type OrganizationExistsPayload {
	"Whether the operation was successful."
	success: Boolean!
	"Whether the organization exists."
	exists: Boolean!
}

type ProjectLinkPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project that was created or updated."
	projectLink: ProjectLink!
	"Whether the operation was successful."
	success: Boolean!
}

type ProjectMilestonePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project milestone that was created or updated."
	projectMilestone: ProjectMilestone!
	"Whether the operation was successful."
	success: Boolean!
}

type ProjectPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project that was created or updated."
	project: Project
	"Whether the operation was successful."
	success: Boolean!
}

type ProjectFilterSuggestionPayload {
	"The json filter that is suggested."
	filter: JSONObject
}

"A generic payload return from entity archive mutations."
type ProjectArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Project
}

type ProjectUpdateInteractionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project update interaction that was created or updated."
	projectUpdateInteraction: ProjectUpdateInteraction!
	"Whether the operation was successful."
	success: Boolean!
}

type ProjectUpdatePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project update that was created or updated."
	projectUpdate: ProjectUpdate!
	"Whether the operation was successful."
	success: Boolean!
}

type ProjectUpdateWithInteractionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The project update that was created or updated."
	projectUpdate: ProjectUpdate!
	"Whether the operation was successful."
	success: Boolean!
	"The project update that was created or updated."
	interaction: ProjectUpdateInteraction!
}

type ProjectUpdateReminderPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
}

type PushSubscriptionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The push subscription that was created or updated."
	entity: PushSubscription!
	"Whether the operation was successful."
	success: Boolean!
}

type PushSubscriptionTestPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type RateLimitPayload {
	"The identifier we rate limit on."
	identifier: String
	"The kind of rate limit selected for this request."
	kind: String!
	"The state of the rate limit."
	limits: [RateLimitResultPayload!]!
}

type RateLimitResultPayload {
	"What is being rate limited."
	type: String!
	"The requested quantity for this type of limit."
	requestedAmount: Float!
	"The total allowed quantity for this type of limit."
	allowedAmount: Float!
	"The period in which the rate limit is fully replenished in ms."
	period: Float!
	"The remaining quantity for this type of limit after this request."
	remainingAmount: Float!
	"The timestamp after the rate limit is fully replenished as a UNIX timestamp."
	reset: Float!
}

type ReactionPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	reaction: Reaction!
	success: Boolean!
}

type ReactionEdge {
	node: Reaction!
	"Used in `before` and `after` args"
	cursor: String!
}

type ReactionConnection {
	edges: [ReactionEdge!]!
	nodes: [Reaction!]!
	pageInfo: PageInfo!
}

type CreateCsvExportReportPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type RoadmapPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The roadmap that was created or updated."
	roadmap: Roadmap!
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type RoadmapArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Roadmap
}

type RoadmapToProjectPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The roadmapToProject that was created or updated."
	roadmapToProject: RoadmapToProject!
	"Whether the operation was successful."
	success: Boolean!
}

"Contains requested archived model objects."
type ArchiveResponse {
	"A JSON serialized collection of model objects loaded from the archive"
	archive: String!
	"The total number of entities in the archive."
	totalCount: Float!
	"The version of the remote database. Incremented by 1 for each migration run on the database."
	databaseVersion: Float!
	"Whether the dependencies for the model objects are included in the archive."
	includesDependencies: Boolean!
}

type IssueSearchResult implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The issue's unique number."
	number: Float!
	"The issue's title."
	title: String!
	"The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low."
	priority: Float!
	"The estimate of the complexity of the issue.."
	estimate: Float
	"The order of the item in its column on the board."
	boardOrder: Float! @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")
	"The order of the item in relation to other items in the organization."
	sortOrder: Float!
	"The time at which the issue was moved into started state."
	startedAt: DateTime
	"The time at which the issue was moved into completed state."
	completedAt: DateTime
	"The time at which the issue entered triage."
	startedTriageAt: DateTime
	"The time at which the issue left triage."
	triagedAt: DateTime
	"The time at which the issue was moved into canceled state."
	canceledAt: DateTime
	"The time at which the issue was automatically closed by the auto pruning process."
	autoClosedAt: DateTime
	"The time at which the issue was automatically archived by the auto pruning process."
	autoArchivedAt: DateTime
	"The date at which the issue is due."
	dueDate: TimelessDate
	"[Internal] The time at which the issue's SLA began."
	slaStartedAt: DateTime
	"[Internal] The time at which the issue's SLA will breach."
	slaBreachesAt: DateTime
	"A flag that indicates whether the issue is in the trash bin."
	trashed: Boolean
	"The time until an issue will be snoozed in Triage view."
	snoozedUntilAt: DateTime
	"Id of the labels associated with this issue."
	labelIds: [String!]!
	"The team that the issue is associated with."
	team: Team!
	"The cycle that the issue is associated with."
	cycle: Cycle
	"The project that the issue is associated with."
	project: Project
	"The projectMilestone that the issue is associated with."
	projectMilestone: ProjectMilestone
	"The last template that was applied to this issue."
	lastAppliedTemplate: Template
	"Previous identifiers of the issue if it has been moved between teams."
	previousIdentifiers: [String!]!
	"The user who created the issue."
	creator: User
	"The external user who created the issue."
	externalUserCreator: ExternalUser
	"The user to whom the issue is assigned to."
	assignee: User
	"The user who snoozed the issue."
	snoozedBy: User
	"The workflow state that the issue is associated with."
	state: WorkflowState!
	"The order of the item in the sub-issue list. Only set if the issue has a parent."
	subIssueSortOrder: Float
	"Label for the priority."
	priorityLabel: String!
	"The comment that this issue was created from."
	sourceComment: Comment
	"Integration type that created this issue, if applicable."
	integrationSourceType: IntegrationService
	"The bot that created the issue, if applicable."
	botActor: ActorBot
	"The users favorite associated with this issue."
	favorite: Favorite
	"Issue's human readable identifier (e.g. ENG-123)."
	identifier: String!
	"Issue URL."
	url: String!
	"Suggested branch name for the issue."
	branchName: String!
	"Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk)."
	customerTicketCount: Int!
	"Users who are subscribed to the issue."
	subscribers(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"The parent of the issue."
	parent: Issue
	"Children of the issue."
	children(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Comments associated with the issue."
	comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
	"History entries associated with the issue."
	history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueHistoryConnection!
	"Labels associated with this issue."
	labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
	"Relations associated with this issue."
	relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
	"Inverse relations associated with this issue."
	inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
	"Attachments associated with the issue."
	attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
	"The issue's description in markdown format."
	description: String
	"[Internal] The issue's description as a Prosemirror document."
	descriptionData: JSON @deprecated(reason: "Use description instead.")
	"[Internal] The issue's description content as YJS state."
	descriptionState: String
	"Metadata related to search result."
	metadata: JSONObject!
}

type DocumentSearchResult implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The document title."
	title: String!
	"The icon of the document."
	icon: String
	"The color of the icon."
	color: String
	"The user who created the document."
	creator: User!
	"The user who last updated the document."
	updatedBy: User!
	"The project that the document is associated with."
	project: Project!
	"The document's unique URL slug."
	slugId: String!
	"The last template that was applied to this document."
	lastAppliedTemplate: Template
	"The time at which the document was hidden. Null if the entity has not been hidden."
	hiddenAt: DateTime
	"The order of the item in the project resources list."
	sortOrder: Float!
	"The documents content in markdown format."
	content: String
	"[Internal] The documents content as YJS state."
	contentState: String
	"[Internal] The documents content as a Prosemirror document."
	contentData: JSON @deprecated(reason: "Use content instead.")
	"Metadata related to search result."
	metadata: JSONObject!
}

type ProjectSearchResult implements Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The project's name."
	name: String!
	"The project's description."
	description: String!
	"The project's unique URL slug."
	slugId: String!
	"The icon of the project."
	icon: String
	"The project's color."
	color: String!
	"The status that the project is associated with."
	status: ProjectStatus!
	"The user who created the project."
	creator: User
	"The project lead."
	lead: User
	"The time until which project update reminders are paused."
	projectUpdateRemindersPausedUntilAt: DateTime
	"The estimated start date of the project."
	startDate: TimelessDate
	"[INTERNAL] The resolution of the project's start date."
	startDateResolution: DateResolutionType
	"The estimated completion date of the project."
	targetDate: TimelessDate
	"[INTERNAL] The resolution of the project's estimated completion date."
	targetDateResolution: DateResolutionType
	"The time at which the project was moved into started state."
	startedAt: DateTime
	"The time at which the project was moved into completed state."
	completedAt: DateTime
	"The time at which the project was moved into canceled state."
	canceledAt: DateTime
	"The time at which the project was automatically archived by the auto pruning process."
	autoArchivedAt: DateTime
	"A flag that indicates whether the project is in the trash bin."
	trashed: Boolean
	"The sort order for the project within the organization."
	sortOrder: Float!
	"The project was created based on this issue."
	convertedFromIssue: Issue
	"The last template that was applied to this project."
	lastAppliedTemplate: Template
	"The total number of issues in the project after each week."
	issueCountHistory: [Float!]!
	"The number of completed issues in the project after each week."
	completedIssueCountHistory: [Float!]!
	"The total number of estimation points after each week."
	scopeHistory: [Float!]!
	"The number of completed estimation points after each week."
	completedScopeHistory: [Float!]!
	"The number of in progress estimation points after each week."
	inProgressScopeHistory: [Float!]!
	"Whether to send new issue notifications to Slack."
	slackNewIssue: Boolean!
	"Whether to send new issue comment notifications to Slack."
	slackIssueComments: Boolean!
	"Whether to send new issue status updates to Slack."
	slackIssueStatuses: Boolean!
	"The user's favorite associated with this project."
	favorite: Favorite
	"Project URL."
	url: String!
	"Teams associated with this project."
	teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"Users that are members of the project."
	members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"Project updates associated with the project."
	projectUpdates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
	"Documents associated with the project."
	documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
	"Milestones associated with the project."
	projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
	"Issues associated with the project."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
	"Links associated with the project."
	links(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLinkConnection!
	"The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points."
	progress: Float!
	"The overall scope (total estimate points) of the project."
	scope: Float!
	"Settings for all integrations associated with that project."
	integrationsSettings: IntegrationsSettings
	"The project's content in markdown format."
	content: String
	"[Internal] The project's content as YJS state."
	contentState: String
	"[DEPRECATED] The type of the state."
	state: String! @deprecated(reason: "Use project.status instead")
	"Metadata related to search result."
	metadata: JSONObject!
}

type IssueSearchResultEdge {
	node: IssueSearchResult!
	"Used in `before` and `after` args"
	cursor: String!
}

type IssueSearchResultConnection {
	edges: [IssueSearchResultEdge!]!
	nodes: [IssueSearchResult!]!
	pageInfo: PageInfo!
}

type IssueSearchPayload {
	edges: [IssueSearchResultEdge!]!
	nodes: [IssueSearchResult!]!
	pageInfo: PageInfo!
	"Archived entities matching the search term along with all their dependencies."
	archivePayload: ArchiveResponse!
	"Total number of results for query without filters applied."
	totalCount: Float!
}

type DocumentSearchResultEdge {
	node: DocumentSearchResult!
	"Used in `before` and `after` args"
	cursor: String!
}

type DocumentSearchResultConnection {
	edges: [DocumentSearchResultEdge!]!
	nodes: [DocumentSearchResult!]!
	pageInfo: PageInfo!
}

type DocumentSearchPayload {
	edges: [DocumentSearchResultEdge!]!
	nodes: [DocumentSearchResult!]!
	pageInfo: PageInfo!
	"Archived entities matching the search term along with all their dependencies."
	archivePayload: ArchiveResponse!
	"Total number of results for query without filters applied."
	totalCount: Float!
}

type ProjectSearchResultEdge {
	node: ProjectSearchResult!
	"Used in `before` and `after` args"
	cursor: String!
}

type ProjectSearchResultConnection {
	edges: [ProjectSearchResultEdge!]!
	nodes: [ProjectSearchResult!]!
	pageInfo: PageInfo!
}

type ProjectSearchPayload {
	edges: [ProjectSearchResultEdge!]!
	nodes: [ProjectSearchResult!]!
	pageInfo: PageInfo!
	"Archived entities matching the search term along with all their dependencies."
	archivePayload: ArchiveResponse!
	"Total number of results for query without filters applied."
	totalCount: Float!
}

type TeamMembershipPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The team membership that was created or updated."
	teamMembership: TeamMembership
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type TeamArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: Team
}

type TeamPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The team that was created or updated."
	team: Team
	"Whether the operation was successful."
	success: Boolean!
}

type TemplatePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The template that was created or updated."
	template: Template!
	"Whether the operation was successful."
	success: Boolean!
}

type TimeSchedulePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	timeSchedule: TimeSchedule!
	"Whether the operation was successful."
	success: Boolean!
}

type TriageResponsibilityPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	triageResponsibility: TriageResponsibility!
	"Whether the operation was successful."
	success: Boolean!
}

type UserPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The user that was created or updated."
	user: User
	"Whether the operation was successful."
	success: Boolean!
}

type UserAdminPayload {
	"Whether the operation was successful."
	success: Boolean!
}

type UserSettingsPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The user's settings."
	userSettings: UserSettings!
	"Whether the operation was successful."
	success: Boolean!
}

type UserSettingsFlagPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The flag key which was updated."
	flag: String!
	"The flag value after update."
	value: Int!
	"Whether the operation was successful."
	success: Boolean!
}

type UserSettingsFlagsResetPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
}

type ViewPreferencesPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The view preferences entity being mutated."
	viewPreferences: ViewPreferences!
	"Whether the operation was successful."
	success: Boolean!
}

type WebhookPayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The webhook entity being mutated."
	webhook: Webhook!
	"Whether the operation was successful."
	success: Boolean!
}

type WorkflowStatePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"The state that was created or updated."
	workflowState: WorkflowState!
	"Whether the operation was successful."
	success: Boolean!
}

"A generic payload return from entity archive mutations."
type WorkflowStateArchivePayload implements ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
	"The archived/unarchived entity. Null if entity was deleted."
	entity: WorkflowState
}

interface Node {
	"The unique identifier of the entity."
	id: ID!
}

"A notification sent to a user."
interface Notification implements Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Notification type."
	type: String!
	"The user that caused the notification."
	actor: User
	"The external user that caused the notification."
	externalUserActor: ExternalUser
	"The user that received the notification."
	user: User!
	"The time at when the user marked the notification as read. Null, if the the user hasn't read the notification"
	readAt: DateTime
	"""
	The time at when an email reminder for this notification was sent to the user. Null, if no email
	    reminder has been sent.
	"""
	emailedAt: DateTime
	"The time until a notification will be snoozed. After that it will appear in the inbox again."
	snoozedUntilAt: DateTime
	"The time at which a notification was unsnoozed.."
	unsnoozedAt: DateTime
	"The bot that caused the notification."
	botActor: ActorBot
}

"Notification subscriptions for models."
interface NotificationSubscription implements Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team associated with the notification subscription."
	team: Team
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
}

"A generic payload return from entity archive or deletion mutations."
interface ArchivePayload {
	"The identifier of the last sync operation."
	lastSyncId: Float!
	"Whether the operation was successful."
	success: Boolean!
}

"Comparator for booleans."
input BooleanComparator {
	"Equals constraint."
	eq: Boolean
	"Not equals constraint."
	neq: Boolean
}

"[Internal] Comparator for content."
input ContentComparator {
	"[Internal] Contains constraint."
	contains: String
	"[Internal] Not-contains constraint."
	notContains: String
}

"Comparator for dates."
input DateComparator {
	"Equals constraint."
	eq: DateTime
	"Not-equals constraint."
	neq: DateTime
	"In-array constraint."
	in: [DateTime!]
	"Not-in-array constraint."
	nin: [DateTime!]
	"Less-than constraint. Matches any values that are less than the given value."
	lt: DateTime
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: DateTime
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: DateTime
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: DateTime
}

"Comparator for optional dates."
input NullableDateComparator {
	"Equals constraint."
	eq: DateTime
	"Not-equals constraint."
	neq: DateTime
	"In-array constraint."
	in: [DateTime!]
	"Not-in-array constraint."
	nin: [DateTime!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Less-than constraint. Matches any values that are less than the given value."
	lt: DateTime
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: DateTime
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: DateTime
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: DateTime
}

"Comparator for estimates."
input EstimateComparator {
	"Equals constraint."
	eq: Float
	"Not-equals constraint."
	neq: Float
	"In-array constraint."
	in: [Float!]
	"Not-in-array constraint."
	nin: [Float!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Less-than constraint. Matches any values that are less than the given value."
	lt: Float
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: Float
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: Float
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: Float
	"Compound filters, all of which need to be matched by the estimate."
	or: [NullableNumberComparator!]
	"Compound filters, one of which need to be matched by the estimate."
	and: [NullableNumberComparator!]
}

"Comparator for relation existence."
input RelationExistsComparator {
	"Equals constraint."
	eq: Boolean
	"Not equals constraint."
	neq: Boolean
}

"Comparator for identifiers."
input IDComparator {
	"Equals constraint."
	eq: ID
	"Not-equals constraint."
	neq: ID
	"In-array constraint."
	in: [ID!]
	"Not-in-array constraint."
	nin: [ID!]
}

"Comparator for numbers."
input NumberComparator {
	"Equals constraint."
	eq: Float
	"Not-equals constraint."
	neq: Float
	"In-array constraint."
	in: [Float!]
	"Not-in-array constraint."
	nin: [Float!]
	"Less-than constraint. Matches any values that are less than the given value."
	lt: Float
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: Float
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: Float
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: Float
}

"Comparator for optional numbers."
input NullableNumberComparator {
	"Equals constraint."
	eq: Float
	"Not-equals constraint."
	neq: Float
	"In-array constraint."
	in: [Float!]
	"Not-in-array constraint."
	nin: [Float!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Less-than constraint. Matches any values that are less than the given value."
	lt: Float
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: Float
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: Float
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: Float
}

"Comparator for strings."
input StringComparator {
	"Equals constraint."
	eq: String
	"Not-equals constraint."
	neq: String
	"In-array constraint."
	in: [String!]
	"Not-in-array constraint."
	nin: [String!]
	"Equals case insensitive. Matches any values that matches the given string case insensitive."
	eqIgnoreCase: String
	"Not-equals case insensitive. Matches any values that don't match the given string case insensitive."
	neqIgnoreCase: String
	"Starts with constraint. Matches any values that start with the given string."
	startsWith: String
	"Starts with case insensitive constraint. Matches any values that start with the given string."
	startsWithIgnoreCase: String
	"Doesn't start with constraint. Matches any values that don't start with the given string."
	notStartsWith: String
	"Ends with constraint. Matches any values that end with the given string."
	endsWith: String
	"Doesn't end with constraint. Matches any values that don't end with the given string."
	notEndsWith: String
	"Contains constraint. Matches any values that contain the given string."
	contains: String
	"Contains case insensitive constraint. Matches any values that contain the given string case insensitive."
	containsIgnoreCase: String
	"Doesn't contain constraint. Matches any values that don't contain the given string."
	notContains: String
	"Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive."
	notContainsIgnoreCase: String
}

"Comparator for optional strings."
input NullableStringComparator {
	"Equals constraint."
	eq: String
	"Not-equals constraint."
	neq: String
	"In-array constraint."
	in: [String!]
	"Not-in-array constraint."
	nin: [String!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Equals case insensitive. Matches any values that matches the given string case insensitive."
	eqIgnoreCase: String
	"Not-equals case insensitive. Matches any values that don't match the given string case insensitive."
	neqIgnoreCase: String
	"Starts with constraint. Matches any values that start with the given string."
	startsWith: String
	"Starts with case insensitive constraint. Matches any values that start with the given string."
	startsWithIgnoreCase: String
	"Doesn't start with constraint. Matches any values that don't start with the given string."
	notStartsWith: String
	"Ends with constraint. Matches any values that end with the given string."
	endsWith: String
	"Doesn't end with constraint. Matches any values that don't end with the given string."
	notEndsWith: String
	"Contains constraint. Matches any values that contain the given string."
	contains: String
	"Contains case insensitive constraint. Matches any values that contain the given string case insensitive."
	containsIgnoreCase: String
	"Doesn't contain constraint. Matches any values that don't contain the given string."
	notContains: String
	"Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive."
	notContainsIgnoreCase: String
}

"Comparator for `sourceType` field."
input SourceTypeComparator {
	"Equals constraint."
	eq: String
	"Not-equals constraint."
	neq: String
	"In-array constraint."
	in: [String!]
	"Not-in-array constraint."
	nin: [String!]
	"Equals case insensitive. Matches any values that matches the given string case insensitive."
	eqIgnoreCase: String
	"Not-equals case insensitive. Matches any values that don't match the given string case insensitive."
	neqIgnoreCase: String
	"Starts with constraint. Matches any values that start with the given string."
	startsWith: String
	"Starts with case insensitive constraint. Matches any values that start with the given string."
	startsWithIgnoreCase: String
	"Doesn't start with constraint. Matches any values that don't start with the given string."
	notStartsWith: String
	"Ends with constraint. Matches any values that end with the given string."
	endsWith: String
	"Doesn't end with constraint. Matches any values that don't end with the given string."
	notEndsWith: String
	"Contains constraint. Matches any values that contain the given string."
	contains: String
	"Contains case insensitive constraint. Matches any values that contain the given string case insensitive."
	containsIgnoreCase: String
	"Doesn't contain constraint. Matches any values that don't contain the given string."
	notContains: String
	"Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive."
	notContainsIgnoreCase: String
}

"Comparator for timeless dates."
input TimelessDateComparator {
	"Equals constraint."
	eq: TimelessDate
	"Not-equals constraint."
	neq: TimelessDate
	"In-array constraint."
	in: [TimelessDate!]
	"Not-in-array constraint."
	nin: [TimelessDate!]
	"Less-than constraint. Matches any values that are less than the given value."
	lt: TimelessDate
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: TimelessDate
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: TimelessDate
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: TimelessDate
}

input NullableTimelessDateComparator {
	"Equals constraint."
	eq: TimelessDate
	"Not-equals constraint."
	neq: TimelessDate
	"In-array constraint."
	in: [TimelessDate!]
	"Not-in-array constraint."
	nin: [TimelessDate!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Less-than constraint. Matches any values that are less than the given value."
	lt: TimelessDate
	"Less-than-or-equal constraint. Matches any values that are less than or equal to the given value."
	lte: TimelessDate
	"Greater-than constraint. Matches any values that are greater than the given value."
	gt: TimelessDate
	"Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value."
	gte: TimelessDate
}

"Comparator for source type."
input SubTypeComparator {
	"Equals constraint."
	eq: String
	"Not-equals constraint."
	neq: String
	"In-array constraint."
	in: [String!]
	"Not-in-array constraint."
	nin: [String!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
}

"Comparator for issue source type."
input SourceMetadataComparator {
	"Equals constraint."
	eq: String
	"Not-equals constraint."
	neq: String
	"In-array constraint."
	in: [String!]
	"Not-in-array constraint."
	nin: [String!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
	"Compound filters, all of which need to be matched by the sub type."
	subType: SubTypeComparator
}

input SlackAsksTeamSettingsInput {
	"The Linear team ID."
	id: String!
	"Whether the default Asks template is enabled in the given channel for this team."
	hasDefaultAsk: Boolean!
}

input SlackChannelNameMappingInput {
	"The Slack channel ID."
	id: String!
	"The Slack channel name."
	name: String!
	"Whether or not the Slack channel is private."
	isPrivate: Boolean
	"Whether or not the Slack channel is shared with an external org."
	isShared: Boolean
	"Whether or not we the Linear Asks bot has been added to this Slack channel."
	botAdded: Boolean
	"Which teams are connected to the channel and settings for those teams."
	teams: [SlackAsksTeamSettingsInput!]!
	"Whether or not top-level messages in this channel should automatically create Asks."
	autoCreateOnMessage: Boolean
	"Whether or not using the :ticket: emoji in this channel should automatically create Asks."
	autoCreateOnEmoji: Boolean
	"Whether or not @-mentioning the bot should automatically create an Ask with the message."
	autoCreateOnBotMention: Boolean
	"The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template."
	autoCreateTemplateId: String
}

input SharedSlackSettingsInput {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
}

input SlackAsksSettingsInput {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
	"The mapping of Slack channel ID => Slack channel name for connected channels."
	slackChannelMapping: [SlackChannelNameMappingInput!]
	"The user role type that is allowed to manage Asks settings."
	canAdministrate: UserRoleType!
}

input IntercomSettingsInput {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
}

input FrontSettingsInput {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
}

input SlackSettingsInput {
	"Slack workspace name"
	teamName: String
	"Slack workspace id"
	teamId: String
	"Enterprise name of the connected Slack enterprise"
	enterpriseName: String
	"Whether Linear should automatically respond with issue unfurls when an issue identifier is mentioned in a Slack message."
	linkOnIssueIdMention: Boolean!
}

input SlackPostSettingsInput {
	channel: String!
	channelId: String!
	configurationUrl: String!
	channelType: SlackChannelType
}

input GitHubSettingsInput {
	"The avatar URL for the GitHub organization."
	orgAvatarUrl: String!
	"The GitHub organization's name."
	orgLogin: String!
	"The names of the repositories connected for the GitHub integration."
	repositories: [GitHubRepoInput!]
	"Mapping of team to repository for syncing."
	repositoriesMapping: [TeamRepoMappingInput!]
}

input GitHubPersonalSettingsInput {
	"The GitHub user's name."
	login: String!
}

input GitHubRepoInput {
	"The full name of the repository."
	fullName: String!
	"The GitHub repo id."
	id: Float!
}

input TeamRepoMappingInput {
	"The Linear team id to map to the given project."
	linearTeamId: String!
	"The GitHub repo id."
	gitHubRepoId: Float!
	"Whether the sync for this mapping is bidirectional."
	bidirectional: Boolean
	"Whether this mapping is the default one for issue creation."
	default: Boolean
}

input GitLabSettingsInput {
	"The self-hosted URL of the GitLab instance."
	url: String
	"Whether the token is limited to a read-only scope."
	readonly: Boolean
	"The ISO timestamp the GitLab access token expires."
	expiresAt: String
}

input GoogleSheetsSettingsInput {
	spreadsheetId: String!
	spreadsheetUrl: String!
	sheetId: Float!
	updatedIssuesAt: DateTime!
}

input JiraProjectDataInput {
	"The Jira id for this project."
	id: String!
	"The Jira key for this project, such as ENG."
	key: String!
	"The Jira name for this project, such as Engineering."
	name: String!
}

input JiraLinearMappingInput {
	"The Jira id for this project."
	jiraProjectId: String!
	"The Linear team id to map to the given project."
	linearTeamId: String!
	"Whether the sync for this mapping is bidirectional."
	bidirectional: Boolean
	"Whether this mapping is the default one for issue creation."
	default: Boolean
}

input JiraSettingsInput {
	"The mapping of Jira project id => Linear team id."
	projectMapping: [JiraLinearMappingInput!]
	"The Jira projects for the organization."
	projects: [JiraProjectDataInput!]!
	"Whether this integration is for Jira Server or not."
	isJiraServer: Boolean = false
}

input JiraPersonalSettingsInput {
	"The name of the Jira site currently authorized through the integration."
	siteName: String
}

input NotionSettingsInput {
	"The ID of the Notion workspace being connected."
	workspaceId: String!
	"The name of the Notion workspace being connected."
	workspaceName: String!
}

input OpsgenieInput {
	"The date when the Opsgenie API failed with an unauthorized error."
	apiFailedWithUnauthorizedErrorAt: DateTime!
}

input PagerDutyInput {
	"The date when the PagerDuty API failed with an unauthorized error."
	apiFailedWithUnauthorizedErrorAt: DateTime!
}

input SentrySettingsInput {
	"The slug of the Sentry organization being connected."
	organizationSlug: String!
}

input ZendeskSettingsInput {
	"Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled)."
	sendNoteOnStatusChange: Boolean
	"Whether an internal message should be added when someone comments on an issue."
	sendNoteOnComment: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is completed."
	automateTicketReopeningOnCompletion: Boolean
	"Whether a ticket should be automatically reopened when its linked Linear issue is cancelled."
	automateTicketReopeningOnCancellation: Boolean
	"Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue"
	automateTicketReopeningOnComment: Boolean
	"The subdomain of the Zendesk organization being connected."
	subdomain: String!
	"The URL of the connected Zendesk organization."
	url: String!
	"The ID of the Linear bot user."
	botUserId: String
}

input IntegrationSettingsInput {
	slack: SlackSettingsInput
	slackAsks: SlackAsksSettingsInput
	slackPost: SlackPostSettingsInput
	slackProjectPost: SlackPostSettingsInput
	slackOrgProjectUpdatesPost: SlackPostSettingsInput
	googleSheets: GoogleSheetsSettingsInput
	gitHub: GitHubSettingsInput
	gitHubPersonal: GitHubPersonalSettingsInput
	gitLab: GitLabSettingsInput
	sentry: SentrySettingsInput
	zendesk: ZendeskSettingsInput
	intercom: IntercomSettingsInput
	front: FrontSettingsInput
	jira: JiraSettingsInput
	notion: NotionSettingsInput
	opsgenie: OpsgenieInput
	pagerDuty: PagerDutyInput
	jiraPersonal: JiraPersonalSettingsInput
}

input TimeScheduleEntryInput {
	"The start date of the schedule in ISO 8601 date-time format."
	startsAt: DateTime!
	"The end date of the schedule in ISO 8601 date-time format."
	endsAt: DateTime!
	"The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference."
	userId: String
	"The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id."
	userEmail: String
}

"Manual triage responsibility using a set of users."
input TriageResponsibilityManualSelectionInput {
	"The set of users responsible for triage."
	userIds: [String!]!
	"[INTERNAL] The index of the current userId used for the assign action when having more than one user."
	assignmentIndex: Int
}

"Attachment filtering options."
input AttachmentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the title."
	title: StringComparator
	"Comparator for the subtitle."
	subtitle: NullableStringComparator
	"Comparator for the url."
	url: StringComparator
	"Filters that the attachments creator must satisfy."
	creator: NullableUserFilter
	"Comparator for the source type."
	sourceType: SourceTypeComparator
	"Compound filters, all of which need to be matched by the attachment."
	and: [AttachmentFilter!]
	"Compound filters, one of which need to be matched by the attachment."
	or: [AttachmentFilter!]
}

"Attachment collection filtering options."
input AttachmentCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the title."
	title: StringComparator
	"Comparator for the subtitle."
	subtitle: NullableStringComparator
	"Comparator for the url."
	url: StringComparator
	"Filters that the attachments creator must satisfy."
	creator: NullableUserFilter
	"Comparator for the source type."
	sourceType: SourceTypeComparator
	"Compound filters, all of which need to be matched by the attachment."
	and: [AttachmentCollectionFilter!]
	"Compound filters, one of which need to be matched by the attachment."
	or: [AttachmentCollectionFilter!]
	"Filters that needs to be matched by some attachments."
	some: AttachmentFilter
	"Filters that needs to be matched by all attachments."
	every: AttachmentFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Audit entry filtering options."
input AuditEntryFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the type."
	type: StringComparator
	"Comparator for the IP address."
	ip: StringComparator
	"Comparator for the country code."
	countryCode: StringComparator
	"Filters that the audit entry actor must satisfy."
	actor: NullableUserFilter
}

"Comment filtering options."
input CommentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the comments body."
	body: StringComparator
	"Filters that the comments creator must satisfy."
	user: UserFilter
	"Filters that the comments issue must satisfy."
	issue: IssueFilter
	"Filters that the comments project update must satisfy."
	projectUpdate: ProjectUpdateFilter
	"Filters that the comments document content must satisfy."
	documentContent: DocumentContentFilter
	"Compound filters, all of which need to be matched by the comment."
	and: [CommentFilter!]
	"Compound filters, one of which need to be matched by the comment."
	or: [CommentFilter!]
}

"Comment filtering options."
input CommentCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the comments body."
	body: StringComparator
	"Filters that the comments creator must satisfy."
	user: UserFilter
	"Filters that the comments issue must satisfy."
	issue: IssueFilter
	"Filters that the comments project update must satisfy."
	projectUpdate: ProjectUpdateFilter
	"Filters that the comments document content must satisfy."
	documentContent: DocumentContentFilter
	"Compound filters, all of which need to be matched by the comment."
	and: [CommentCollectionFilter!]
	"Compound filters, one of which need to be matched by the comment."
	or: [CommentCollectionFilter!]
	"Filters that needs to be matched by some comments."
	some: CommentFilter
	"Filters that needs to be matched by all comments."
	every: CommentFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Cycle filtering options."
input CycleFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the cycle number."
	number: NumberComparator
	"Comparator for the cycle name."
	name: StringComparator
	"Comparator for the cycle start date."
	startsAt: DateComparator
	"Comparator for the cycle ends at date."
	endsAt: DateComparator
	"Comparator for the cycle completed at date."
	completedAt: DateComparator
	"Comparator for the filtering active cycle."
	isActive: BooleanComparator
	"Comparator for filtering for whether the cycle is currently in cooldown."
	isInCooldown: BooleanComparator
	"Comparator for the filtering next cycle."
	isNext: BooleanComparator
	"Comparator for the filtering previous cycle."
	isPrevious: BooleanComparator
	"Comparator for the filtering future cycles."
	isFuture: BooleanComparator
	"Comparator for the filtering past cycles."
	isPast: BooleanComparator
	"Filters that the cycles team must satisfy."
	team: TeamFilter
	"Filters that the cycles issues must satisfy."
	issues: IssueCollectionFilter
	"Compound filters, all of which need to be matched by the cycle."
	and: [CycleFilter!]
	"Compound filters, one of which need to be matched by the cycle."
	or: [CycleFilter!]
}

"Cycle filtering options."
input NullableCycleFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the cycle number."
	number: NumberComparator
	"Comparator for the cycle name."
	name: StringComparator
	"Comparator for the cycle start date."
	startsAt: DateComparator
	"Comparator for the cycle ends at date."
	endsAt: DateComparator
	"Comparator for the cycle completed at date."
	completedAt: DateComparator
	"Comparator for the filtering active cycle."
	isActive: BooleanComparator
	"Comparator for filtering for whether the cycle is currently in cooldown."
	isInCooldown: BooleanComparator
	"Comparator for the filtering next cycle."
	isNext: BooleanComparator
	"Comparator for the filtering previous cycle."
	isPrevious: BooleanComparator
	"Comparator for the filtering future cycles."
	isFuture: BooleanComparator
	"Comparator for the filtering past cycles."
	isPast: BooleanComparator
	"Filters that the cycles team must satisfy."
	team: TeamFilter
	"Filters that the cycles issues must satisfy."
	issues: IssueCollectionFilter
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, one of which need to be matched by the cycle."
	and: [NullableCycleFilter!]
	"Compound filters, one of which need to be matched by the cycle."
	or: [NullableCycleFilter!]
}

"Project status filtering options."
input ProjectStatusFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project status name."
	name: StringComparator
	"Comparator for the project status description."
	description: StringComparator
	"Comparator for the project status position."
	position: NumberComparator
	"Comparator for the project status type."
	type: StringComparator
	"Filters that the project status projects must satisfy."
	projects: ProjectCollectionFilter
	"Compound filters, all of which need to be matched by the project status."
	and: [ProjectStatusFilter!]
	"Compound filters, one of which needs to be matched by the project status."
	or: [ProjectStatusFilter!]
}

"Template filtering options."
input NullableTemplateFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the template's name."
	name: StringComparator
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the template."
	and: [NullableTemplateFilter!]
	"Compound filters, one of which need to be matched by the template."
	or: [NullableTemplateFilter!]
}

"User filtering options."
input UserFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the user's name."
	name: StringComparator
	"Comparator for the user's display name."
	displayName: StringComparator
	"Comparator for the user's email."
	email: StringComparator
	"Comparator for the user's activity status."
	active: BooleanComparator
	"Filters that the users assigned issues must satisfy."
	assignedIssues: IssueCollectionFilter
	"Comparator for the user's admin status."
	admin: BooleanComparator
	"Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user."
	isMe: BooleanComparator
	"Compound filters, all of which need to be matched by the user."
	and: [UserFilter!]
	"Compound filters, one of which need to be matched by the user."
	or: [UserFilter!]
}

"User filtering options."
input NullableUserFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the user's name."
	name: StringComparator
	"Comparator for the user's display name."
	displayName: StringComparator
	"Comparator for the user's email."
	email: StringComparator
	"Comparator for the user's activity status."
	active: BooleanComparator
	"Filters that the users assigned issues must satisfy."
	assignedIssues: IssueCollectionFilter
	"Comparator for the user's admin status."
	admin: BooleanComparator
	"Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user."
	isMe: BooleanComparator
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the user."
	and: [NullableUserFilter!]
	"Compound filters, one of which need to be matched by the user."
	or: [NullableUserFilter!]
}

"User filtering options."
input UserCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the user's name."
	name: StringComparator
	"Comparator for the user's display name."
	displayName: StringComparator
	"Comparator for the user's email."
	email: StringComparator
	"Comparator for the user's activity status."
	active: BooleanComparator
	"Filters that the users assigned issues must satisfy."
	assignedIssues: IssueCollectionFilter
	"Comparator for the user's admin status."
	admin: BooleanComparator
	"Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user."
	isMe: BooleanComparator
	"Compound filters, all of which need to be matched by the user."
	and: [UserCollectionFilter!]
	"Compound filters, one of which need to be matched by the user."
	or: [UserCollectionFilter!]
	"Filters that needs to be matched by some users."
	some: UserFilter
	"Filters that needs to be matched by all users."
	every: UserFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Initiative filtering options."
input InitiativeFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the initiative name."
	name: StringComparator
	"Comparator for the initiative slug ID."
	slugId: StringComparator
	"Filters that the initiative creator must satisfy."
	creator: UserFilter
	"Compound filters, all of which need to be matched by the initiative."
	and: [InitiativeFilter!]
	"Compound filters, one of which need to be matched by the initiative."
	or: [InitiativeFilter!]
}

"Initiative collection filtering options."
input InitiativeCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the initiative name."
	name: StringComparator
	"Comparator for the initiative slug ID."
	slugId: StringComparator
	"Filters that the initiative creator must satisfy."
	creator: UserFilter
	"Compound filters, all of which need to be matched by the initiative."
	and: [InitiativeCollectionFilter!]
	"Compound filters, one of which need to be matched by the initiative."
	or: [InitiativeCollectionFilter!]
	"Filters that needs to be matched by some initiatives."
	some: InitiativeFilter
	"Filters that needs to be matched by all initiatives."
	every: InitiativeFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Project filtering options."
input ProjectFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project name."
	name: StringComparator
	"Comparator for the project slug ID."
	slugId: StringComparator
	"[DEPRECATED] Comparator for the project state."
	state: StringComparator
	"Filters that the project's status must satisfy."
	status: ProjectStatusFilter
	"[Internal] Comparator for the project's content."
	searchableContent: ContentComparator
	"Comparator for the project completion date."
	completedAt: NullableDateComparator
	"Comparator for the project start date."
	startDate: NullableDateComparator
	"Comparator for the project target date."
	targetDate: NullableDateComparator
	"Comparator for the project health."
	health: StringComparator
	"Filters that the projects creator must satisfy."
	creator: UserFilter
	"Filters that the projects lead must satisfy."
	lead: NullableUserFilter
	"Filters that the projects members must satisfy."
	members: UserFilter
	"Filters that the projects issues must satisfy."
	issues: IssueCollectionFilter
	"Filters that the projects roadmaps must satisfy."
	roadmaps: RoadmapCollectionFilter
	"Filters that the projects initiatives must satisfy."
	initiatives: InitiativeCollectionFilter
	"Filters that the project's milestones must satisfy."
	projectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's completed milestones must satisfy."
	completedProjectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's next milestone must satisfy."
	nextProjectMilestone: ProjectMilestoneFilter
	"Filters that the project's team must satisfy."
	accessibleTeams: TeamCollectionFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Compound filters, all of which need to be matched by the project."
	and: [ProjectFilter!]
	"Compound filters, one of which need to be matched by the project."
	or: [ProjectFilter!]
}

"Project filtering options."
input NullableProjectFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project name."
	name: StringComparator
	"Comparator for the project slug ID."
	slugId: StringComparator
	"[DEPRECATED] Comparator for the project state."
	state: StringComparator
	"Filters that the project's status must satisfy."
	status: ProjectStatusFilter
	"[Internal] Comparator for the project's content."
	searchableContent: ContentComparator
	"Comparator for the project completion date."
	completedAt: NullableDateComparator
	"Comparator for the project start date."
	startDate: NullableDateComparator
	"Comparator for the project target date."
	targetDate: NullableDateComparator
	"Comparator for the project health."
	health: StringComparator
	"Filters that the projects creator must satisfy."
	creator: UserFilter
	"Filters that the projects lead must satisfy."
	lead: NullableUserFilter
	"Filters that the projects members must satisfy."
	members: UserFilter
	"Filters that the projects issues must satisfy."
	issues: IssueCollectionFilter
	"Filters that the projects roadmaps must satisfy."
	roadmaps: RoadmapCollectionFilter
	"Filters that the projects initiatives must satisfy."
	initiatives: InitiativeCollectionFilter
	"Filters that the project's milestones must satisfy."
	projectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's completed milestones must satisfy."
	completedProjectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's next milestone must satisfy."
	nextProjectMilestone: ProjectMilestoneFilter
	"Filters that the project's team must satisfy."
	accessibleTeams: TeamCollectionFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the project."
	and: [NullableProjectFilter!]
	"Compound filters, one of which need to be matched by the project."
	or: [NullableProjectFilter!]
}

"Project filtering options."
input ProjectCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project name."
	name: StringComparator
	"Comparator for the project slug ID."
	slugId: StringComparator
	"[DEPRECATED] Comparator for the project state."
	state: StringComparator
	"Filters that the project's status must satisfy."
	status: ProjectStatusFilter
	"[Internal] Comparator for the project's content."
	searchableContent: ContentComparator
	"Comparator for the project completion date."
	completedAt: NullableDateComparator
	"Comparator for the project start date."
	startDate: NullableDateComparator
	"Comparator for the project target date."
	targetDate: NullableDateComparator
	"Comparator for the project health."
	health: StringComparator
	"Filters that the projects creator must satisfy."
	creator: UserFilter
	"Filters that the projects lead must satisfy."
	lead: NullableUserFilter
	"Filters that the projects members must satisfy."
	members: UserFilter
	"Filters that the projects issues must satisfy."
	issues: IssueCollectionFilter
	"Filters that the projects roadmaps must satisfy."
	roadmaps: RoadmapCollectionFilter
	"Filters that the projects initiatives must satisfy."
	initiatives: InitiativeCollectionFilter
	"Filters that the project's milestones must satisfy."
	projectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's completed milestones must satisfy."
	completedProjectMilestones: ProjectMilestoneCollectionFilter
	"Filters that the project's next milestone must satisfy."
	nextProjectMilestone: ProjectMilestoneFilter
	"Filters that the project's team must satisfy."
	accessibleTeams: TeamCollectionFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Compound filters, all of which need to be matched by the project."
	and: [ProjectCollectionFilter!]
	"Compound filters, one of which need to be matched by the project."
	or: [ProjectCollectionFilter!]
	"Filters that needs to be matched by some projects."
	some: ProjectFilter
	"Filters that needs to be matched by all projects."
	every: ProjectFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Project milestone filtering options."
input ProjectMilestoneFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project milestone name."
	name: StringComparator
	"Comparator for the project milestone target date."
	targetDate: NullableDateComparator
	"Compound filters, all of which need to be matched by the project milestone."
	and: [ProjectMilestoneFilter!]
	"Compound filters, one of which need to be matched by the project milestone."
	or: [ProjectMilestoneFilter!]
}

"Project milestone filtering options."
input NullableProjectMilestoneFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project milestone name."
	name: StringComparator
	"Comparator for the project milestone target date."
	targetDate: NullableDateComparator
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the project milestone."
	and: [NullableProjectMilestoneFilter!]
	"Compound filters, one of which need to be matched by the project milestone."
	or: [NullableProjectMilestoneFilter!]
}

"Milestone collection filtering options."
input ProjectMilestoneCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the project milestone name."
	name: StringComparator
	"Comparator for the project milestone target date."
	targetDate: NullableDateComparator
	"Compound filters, all of which need to be matched by the milestone."
	and: [ProjectMilestoneCollectionFilter!]
	"Compound filters, one of which need to be matched by the milestone."
	or: [ProjectMilestoneCollectionFilter!]
	"Filters that needs to be matched by some milestones."
	some: ProjectMilestoneFilter
	"Filters that needs to be matched by all milestones."
	every: ProjectMilestoneFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Roadmap filtering options."
input RoadmapFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the roadmap name."
	name: StringComparator
	"Comparator for the roadmap slug ID."
	slugId: StringComparator
	"Filters that the roadmap creator must satisfy."
	creator: UserFilter
	"Compound filters, all of which need to be matched by the roadmap."
	and: [RoadmapFilter!]
	"Compound filters, one of which need to be matched by the roadmap."
	or: [RoadmapFilter!]
}

"Roadmap collection filtering options."
input RoadmapCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the roadmap name."
	name: StringComparator
	"Comparator for the roadmap slug ID."
	slugId: StringComparator
	"Filters that the roadmap creator must satisfy."
	creator: UserFilter
	"Compound filters, all of which need to be matched by the roadmap."
	and: [RoadmapCollectionFilter!]
	"Compound filters, one of which need to be matched by the roadmap."
	or: [RoadmapCollectionFilter!]
	"Filters that needs to be matched by some roadmaps."
	some: RoadmapFilter
	"Filters that needs to be matched by all roadmaps."
	every: RoadmapFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Team filtering options."
input TeamFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the team name."
	name: StringComparator
	"Comparator for the team key."
	key: StringComparator
	"Comparator for the team description."
	description: NullableStringComparator
	"Filters that the teams issues must satisfy."
	issues: IssueCollectionFilter
	"Compound filters, all of which need to be matched by the team."
	and: [TeamFilter!]
	"Compound filters, one of which need to be matched by the team."
	or: [TeamFilter!]
}

"Team filtering options."
input NullableTeamFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the team name."
	name: StringComparator
	"Comparator for the team key."
	key: StringComparator
	"Comparator for the team description."
	description: NullableStringComparator
	"Filters that the teams issues must satisfy."
	issues: IssueCollectionFilter
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the team."
	and: [NullableTeamFilter!]
	"Compound filters, one of which need to be matched by the team."
	or: [NullableTeamFilter!]
}

"Roadmap collection filtering options."
input TeamCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Compound filters, all of which need to be matched by the roadmap."
	and: [TeamCollectionFilter!]
	"Compound filters, one of which need to be matched by the roadmap."
	or: [TeamCollectionFilter!]
	"Filters that needs to be matched by some roadmaps."
	some: TeamFilter
	"Filters that needs to be matched by all roadmaps."
	every: TeamFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Workflow state filtering options."
input WorkflowStateFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the workflow state name."
	name: StringComparator
	"Comparator for the workflow state description."
	description: StringComparator
	"Comparator for the workflow state position."
	position: NumberComparator
	"Comparator for the workflow state type."
	type: StringComparator
	"Filters that the workflow states team must satisfy."
	team: TeamFilter
	"Filters that the workflow states issues must satisfy."
	issues: IssueCollectionFilter
	"Compound filters, all of which need to be matched by the workflow state."
	and: [WorkflowStateFilter!]
	"Compound filters, one of which need to be matched by the workflow state."
	or: [WorkflowStateFilter!]
}

"Document content filtering options."
input NullableDocumentContentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Filters that the document content project must satisfy."
	project: ProjectFilter
	"Filters that the document content document must satisfy."
	document: DocumentFilter
}

"Document content filtering options."
input DocumentContentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Filters that the document content project must satisfy."
	project: ProjectFilter
	"Filters that the document content document must satisfy."
	document: DocumentFilter
}

"Issue label filtering options."
input IssueLabelFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the name."
	name: StringComparator
	"Filters that the issue labels creator must satisfy."
	creator: NullableUserFilter
	"Filters that the issue labels team must satisfy."
	team: NullableTeamFilter
	"Filters that the issue label's parent label must satisfy."
	parent: IssueLabelFilter
	"Compound filters, all of which need to be matched by the label."
	and: [IssueLabelFilter!]
	"Compound filters, one of which need to be matched by the label."
	or: [IssueLabelFilter!]
}

"Issue label filtering options."
input IssueLabelCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the name."
	name: StringComparator
	"Filters that the issue labels creator must satisfy."
	creator: NullableUserFilter
	"Filters that the issue labels team must satisfy."
	team: NullableTeamFilter
	"Filters that the issue label's parent label must satisfy."
	parent: IssueLabelFilter
	"Compound filters, all of which need to be matched by the label."
	and: [IssueLabelCollectionFilter!]
	"Compound filters, one of which need to be matched by the label."
	or: [IssueLabelCollectionFilter!]
	"Filters that needs to be matched by some issue labels."
	some: IssueLabelFilter
	"Filters that needs to be matched by all issue labels."
	every: IssueLabelFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"ProjectUpdate filtering options."
input ProjectUpdateFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Filters that the project update creator must satisfy."
	user: UserFilter
	"Filters that the project update project must satisfy."
	project: ProjectFilter
	"Compound filters, all of which need to be matched by the ProjectUpdate."
	and: [ProjectUpdateFilter!]
	"Compound filters, one of which need to be matched by the ProjectUpdate."
	or: [ProjectUpdateFilter!]
}

"Document filtering options."
input DocumentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the document title."
	title: StringComparator
	"Comparator for the document slug ID."
	slugId: StringComparator
	"Filters that the document's creator must satisfy."
	creator: UserFilter
	"Filters that the document's project must satisfy."
	project: ProjectFilter
	"Compound filters, all of which need to be matched by the document."
	and: [DocumentFilter!]
	"Compound filters, one of which need to be matched by the document."
	or: [DocumentFilter!]
}

"Document filtering options."
input NullableDocumentFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the document title."
	title: StringComparator
	"Comparator for the document slug ID."
	slugId: StringComparator
	"Filters that the document's creator must satisfy."
	creator: UserFilter
	"Filters that the document's project must satisfy."
	project: ProjectFilter
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the document."
	and: [NullableDocumentFilter!]
	"Compound filters, one of which need to be matched by the document."
	or: [NullableDocumentFilter!]
}

"Document filtering options."
input DocumentCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the document title."
	title: StringComparator
	"Comparator for the document slug ID."
	slugId: StringComparator
	"Filters that the document's creator must satisfy."
	creator: UserFilter
	"Filters that the document's project must satisfy."
	project: ProjectFilter
	"Compound filters, all of which need to be matched by the document."
	and: [DocumentCollectionFilter!]
	"Compound filters, one of which need to be matched by the document."
	or: [DocumentCollectionFilter!]
	"Filters that needs to be matched by some documents."
	some: DocumentFilter
	"Filters that needs to be matched by all documents."
	every: DocumentFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"Comparator for sla status."
input SlaStatusComparator {
	"Equals constraint."
	eq: SlaStatus
	"Not-equals constraint."
	neq: SlaStatus
	"In-array constraint."
	in: [SlaStatus!]
	"Not-in-array constraint."
	nin: [SlaStatus!]
	"Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values."
	null: Boolean
}

enum SlaStatus {
	Breached
	HighRisk
	MediumRisk
	LowRisk
	Completed
	Failed
	Paused
}

"Issue filtering options."
input NullableIssueFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the issues number."
	number: NumberComparator
	"Comparator for the issues title."
	title: StringComparator
	"Comparator for the issues description."
	description: NullableStringComparator
	"Comparator for the issues priority."
	priority: NullableNumberComparator
	"Comparator for the issues estimate."
	estimate: EstimateComparator
	"Comparator for the issues started at date."
	startedAt: NullableDateComparator
	"Comparator for the issues triaged at date."
	triagedAt: NullableDateComparator
	"Comparator for the issues completed at date."
	completedAt: NullableDateComparator
	"Comparator for the issues canceled at date."
	canceledAt: NullableDateComparator
	"Comparator for the issues auto closed at date."
	autoClosedAt: NullableDateComparator
	"Comparator for the issues auto archived at date."
	autoArchivedAt: NullableDateComparator
	"Comparator for the issues due date."
	dueDate: NullableTimelessDateComparator
	"Comparator for the issues snoozed until date."
	snoozedUntilAt: NullableDateComparator
	"Filters that the issues assignee must satisfy."
	assignee: NullableUserFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Filters that the source must satisfy."
	sourceMetadata: SourceMetadataComparator
	"Filters that the issues creator must satisfy."
	creator: NullableUserFilter
	"Filters that the issue parent must satisfy."
	parent: NullableIssueFilter
	"Filters that the issues snoozer must satisfy."
	snoozedBy: NullableUserFilter
	"Filters that issue labels must satisfy."
	labels: IssueLabelCollectionFilter
	"Filters that issue subscribers must satisfy."
	subscribers: UserCollectionFilter
	"Filters that the issues team must satisfy."
	team: TeamFilter
	"Filters that the issues project milestone must satisfy."
	projectMilestone: NullableProjectMilestoneFilter
	"Filters that the issues comments must satisfy."
	comments: CommentCollectionFilter
	"Filters that the issues cycle must satisfy."
	cycle: NullableCycleFilter
	"Filters that the issues project must satisfy."
	project: NullableProjectFilter
	"Filters that the issues state must satisfy."
	state: WorkflowStateFilter
	"Filters that the child issues must satisfy."
	children: IssueCollectionFilter
	"Filters that the issues attachments must satisfy."
	attachments: AttachmentCollectionFilter
	"[Internal] Comparator for the issues content."
	searchableContent: ContentComparator
	"Comparator for filtering issues with relations."
	hasRelatedRelations: RelationExistsComparator
	"Comparator for filtering issues which are duplicates."
	hasDuplicateRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocked."
	hasBlockedByRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocking."
	hasBlockingRelations: RelationExistsComparator
	"Comparator for the issues sla status."
	slaStatus: SlaStatusComparator
	"Filter based on the existence of the relation."
	null: Boolean
	"Compound filters, all of which need to be matched by the issue."
	and: [NullableIssueFilter!]
	"Compound filters, one of which need to be matched by the issue."
	or: [NullableIssueFilter!]
}

"Issue filtering options."
input IssueFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the issues number."
	number: NumberComparator
	"Comparator for the issues title."
	title: StringComparator
	"Comparator for the issues description."
	description: NullableStringComparator
	"Comparator for the issues priority."
	priority: NullableNumberComparator
	"Comparator for the issues estimate."
	estimate: EstimateComparator
	"Comparator for the issues started at date."
	startedAt: NullableDateComparator
	"Comparator for the issues triaged at date."
	triagedAt: NullableDateComparator
	"Comparator for the issues completed at date."
	completedAt: NullableDateComparator
	"Comparator for the issues canceled at date."
	canceledAt: NullableDateComparator
	"Comparator for the issues auto closed at date."
	autoClosedAt: NullableDateComparator
	"Comparator for the issues auto archived at date."
	autoArchivedAt: NullableDateComparator
	"Comparator for the issues due date."
	dueDate: NullableTimelessDateComparator
	"Comparator for the issues snoozed until date."
	snoozedUntilAt: NullableDateComparator
	"Filters that the issues assignee must satisfy."
	assignee: NullableUserFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Filters that the source must satisfy."
	sourceMetadata: SourceMetadataComparator
	"Filters that the issues creator must satisfy."
	creator: NullableUserFilter
	"Filters that the issue parent must satisfy."
	parent: NullableIssueFilter
	"Filters that the issues snoozer must satisfy."
	snoozedBy: NullableUserFilter
	"Filters that issue labels must satisfy."
	labels: IssueLabelCollectionFilter
	"Filters that issue subscribers must satisfy."
	subscribers: UserCollectionFilter
	"Filters that the issues team must satisfy."
	team: TeamFilter
	"Filters that the issues project milestone must satisfy."
	projectMilestone: NullableProjectMilestoneFilter
	"Filters that the issues comments must satisfy."
	comments: CommentCollectionFilter
	"Filters that the issues cycle must satisfy."
	cycle: NullableCycleFilter
	"Filters that the issues project must satisfy."
	project: NullableProjectFilter
	"Filters that the issues state must satisfy."
	state: WorkflowStateFilter
	"Filters that the child issues must satisfy."
	children: IssueCollectionFilter
	"Filters that the issues attachments must satisfy."
	attachments: AttachmentCollectionFilter
	"[Internal] Comparator for the issues content."
	searchableContent: ContentComparator
	"Comparator for filtering issues with relations."
	hasRelatedRelations: RelationExistsComparator
	"Comparator for filtering issues which are duplicates."
	hasDuplicateRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocked."
	hasBlockedByRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocking."
	hasBlockingRelations: RelationExistsComparator
	"Comparator for the issues sla status."
	slaStatus: SlaStatusComparator
	"Compound filters, all of which need to be matched by the issue."
	and: [IssueFilter!]
	"Compound filters, one of which need to be matched by the issue."
	or: [IssueFilter!]
}

"Issue filtering options."
input IssueCollectionFilter {
	"Comparator for the identifier."
	id: IDComparator
	"Comparator for the created at date."
	createdAt: DateComparator
	"Comparator for the updated at date."
	updatedAt: DateComparator
	"Comparator for the issues number."
	number: NumberComparator
	"Comparator for the issues title."
	title: StringComparator
	"Comparator for the issues description."
	description: NullableStringComparator
	"Comparator for the issues priority."
	priority: NullableNumberComparator
	"Comparator for the issues estimate."
	estimate: EstimateComparator
	"Comparator for the issues started at date."
	startedAt: NullableDateComparator
	"Comparator for the issues triaged at date."
	triagedAt: NullableDateComparator
	"Comparator for the issues completed at date."
	completedAt: NullableDateComparator
	"Comparator for the issues canceled at date."
	canceledAt: NullableDateComparator
	"Comparator for the issues auto closed at date."
	autoClosedAt: NullableDateComparator
	"Comparator for the issues auto archived at date."
	autoArchivedAt: NullableDateComparator
	"Comparator for the issues due date."
	dueDate: NullableTimelessDateComparator
	"Comparator for the issues snoozed until date."
	snoozedUntilAt: NullableDateComparator
	"Filters that the issues assignee must satisfy."
	assignee: NullableUserFilter
	"Filters that the last applied template must satisfy."
	lastAppliedTemplate: NullableTemplateFilter
	"Filters that the source must satisfy."
	sourceMetadata: SourceMetadataComparator
	"Filters that the issues creator must satisfy."
	creator: NullableUserFilter
	"Filters that the issue parent must satisfy."
	parent: NullableIssueFilter
	"Filters that the issues snoozer must satisfy."
	snoozedBy: NullableUserFilter
	"Filters that issue labels must satisfy."
	labels: IssueLabelCollectionFilter
	"Filters that issue subscribers must satisfy."
	subscribers: UserCollectionFilter
	"Filters that the issues team must satisfy."
	team: TeamFilter
	"Filters that the issues project milestone must satisfy."
	projectMilestone: NullableProjectMilestoneFilter
	"Filters that the issues comments must satisfy."
	comments: CommentCollectionFilter
	"Filters that the issues cycle must satisfy."
	cycle: NullableCycleFilter
	"Filters that the issues project must satisfy."
	project: NullableProjectFilter
	"Filters that the issues state must satisfy."
	state: WorkflowStateFilter
	"Filters that the child issues must satisfy."
	children: IssueCollectionFilter
	"Filters that the issues attachments must satisfy."
	attachments: AttachmentCollectionFilter
	"[Internal] Comparator for the issues content."
	searchableContent: ContentComparator
	"Comparator for filtering issues with relations."
	hasRelatedRelations: RelationExistsComparator
	"Comparator for filtering issues which are duplicates."
	hasDuplicateRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocked."
	hasBlockedByRelations: RelationExistsComparator
	"Comparator for filtering issues which are blocking."
	hasBlockingRelations: RelationExistsComparator
	"Comparator for the issues sla status."
	slaStatus: SlaStatusComparator
	"Compound filters, all of which need to be matched by the issue."
	and: [IssueCollectionFilter!]
	"Compound filters, one of which need to be matched by the issue."
	or: [IssueCollectionFilter!]
	"Filters that needs to be matched by some issues."
	some: IssueFilter
	"Filters that needs to be matched by all issues."
	every: IssueFilter
	"Comparator for the collection length."
	length: NumberComparator
}

"A condition to match for the workflow to be triggered."
input WorkflowCondition {
	"Trigger the workflow when an issue matches the filter. Can only be used when the trigger type is `Issue`."
	issueFilter: IssueFilter
	"Triggers the workflow when a project matches the filter. Can only be used when the trigger type is `Project`."
	projectFilter: ProjectFilter
}

input IssueCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The title of the issue."
	title: String
	"The issue description in markdown format."
	description: String
	"[Internal] The issue description as a Prosemirror document."
	descriptionData: JSON
	"The identifier of the user to assign the issue to."
	assigneeId: String
	"The identifier of the parent issue."
	parentId: String
	"The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low."
	priority: Int
	"The estimated complexity of the issue."
	estimate: Int
	"The identifiers of the users subscribing to this ticket."
	subscriberIds: [String!]
	"The identifiers of the issue labels associated with this ticket."
	labelIds: [String!]
	"The identifier or key of the team associated with the issue."
	teamId: String!
	"The cycle associated with the issue."
	cycleId: String
	"The project associated with the issue."
	projectId: String
	"The project milestone associated with the issue."
	projectMilestoneId: String
	"The ID of the last template applied to the issue."
	lastAppliedTemplateId: String
	"The team state of the issue."
	stateId: String
	"The comment the issue is referencing."
	referenceCommentId: String
	"The comment the issue is created from."
	sourceCommentId: String
	"The position of the issue in its column on the board view."
	boardOrder: Float
	"The position of the issue related to other issues."
	sortOrder: Float
	"The position of the issue in parent's sub-issue list."
	subIssueSortOrder: Float
	"The date at which the issue is due."
	dueDate: TimelessDate
	"Create issue as a user with the provided name. This option is only available to OAuth applications creating issues in `actor=application` mode."
	createAsUser: String
	"Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode."
	displayIconUrl: String
	"Whether the passed sort order should be preserved."
	preserveSortOrderOnCreate: Boolean
	"The date when the issue was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now."
	createdAt: DateTime
	"[Internal] The timestamp at which an issue will be considered in breach of SLA."
	slaBreachesAt: DateTime
	"The identifier of a template the issue should be created from. If other values are provided in the input, they will override template values."
	templateId: String
}

input IssueUpdateInput {
	"The issue title."
	title: String
	"The issue description in markdown format."
	description: String
	"The issue description as a Prosemirror document."
	descriptionData: JSON
	"The identifier of the user to assign the issue to."
	assigneeId: String
	"The identifier of the parent issue."
	parentId: String
	"The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low."
	priority: Int
	"The estimated complexity of the issue."
	estimate: Int
	"The identifiers of the users subscribing to this ticket."
	subscriberIds: [String!]
	"The identifiers of the issue labels associated with this ticket."
	labelIds: [String!]
	"The identifier or key of the team associated with the issue."
	teamId: String
	"The cycle associated with the issue."
	cycleId: String
	"The project associated with the issue."
	projectId: String
	"The project milestone associated with the issue."
	projectMilestoneId: String
	"The ID of the last template applied to the issue."
	lastAppliedTemplateId: String
	"The team state of the issue."
	stateId: String
	"The position of the issue in its column on the board view."
	boardOrder: Float
	"The position of the issue related to other issues."
	sortOrder: Float
	"The position of the issue in parent's sub-issue list."
	subIssueSortOrder: Float
	"The date at which the issue is due."
	dueDate: TimelessDate
	"Whether the issue has been trashed."
	trashed: Boolean
	"[Internal] The timestamp at which an issue will be considered in breach of SLA."
	slaBreachesAt: DateTime
	"The time until an issue will be snoozed in Triage view."
	snoozedUntilAt: DateTime
	"The identifier of the user who snoozed the issue."
	snoozedById: String
	"The identifiers of the companies associated with this ticket."
	companyIds: [String!]
}

input AuthApiKeyCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The label for the API key."
	label: String!
	"The API key value."
	key: String!
}

input ApiKeyCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The label for the API key."
	label: String!
	"The API key value."
	key: String!
}

input AttachmentCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The attachment title."
	title: String!
	"The attachment subtitle."
	subtitle: String
	"Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead."
	url: String!
	"The issue to associate the attachment with."
	issueId: String!
	"An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality."
	iconUrl: String
	"Attachment metadata object with string and number values."
	metadata: JSONObject
	"Indicates if attachments for the same source application should be grouped in the Linear UI."
	groupBySource: Boolean
	"Create a linked comment with markdown body."
	commentBody: String
	"[Internal] Create a linked comment with Prosemirror body. Please use `commentBody` instead."
	commentBodyData: JSONObject
	"Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode."
	createAsUser: String
}

input AttachmentUpdateInput {
	"The attachment title."
	title: String!
	"The attachment subtitle."
	subtitle: String
	"Attachment metadata object with string and number values."
	metadata: JSONObject
	"An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality."
	iconUrl: String
}

input OnboardingCustomerSurvey {
	companyRole: String
	companySize: String
}

input CreateOrganizationInput {
	"The name of the organization."
	name: String!
	"The URL key of the organization."
	urlKey: String!
	"Whether the organization should allow email domain access."
	domainAccess: Boolean
	"The timezone of the organization, passed in by client."
	timezone: String
	"JSON serialized UTM parameters associated with the creation of the workspace."
	utm: String
}

input JoinOrganizationInput {
	"The identifier of the organization."
	organizationId: String!
	"An optional invite link for an organization."
	inviteLink: String
}

input EmailUserAccountAuthChallengeInput {
	"The email for which to generate the magic login code."
	email: String!
	"Whether the login was requested from the desktop app."
	isDesktop: Boolean
	"Auth code for the client initiating the sequence."
	clientAuthCode: String
	"Signup code."
	signupCode: String
	"The organization invite link to associate with this authentication."
	inviteLink: String
}

input TokenUserAccountAuthInput {
	"The email which to login via the magic login code."
	email: String!
	"The magic login code."
	token: String!
	"The timezone of the user's browser."
	timezone: String!
	"The identifiers of the teams to auto-join."
	teamIdsToJoin: [String!]
	"An optional invite link for an organization."
	inviteLink: String
}

input GoogleUserAccountAuthInput {
	"Code returned from Google's OAuth flow."
	code: String!
	"The URI to redirect the user to."
	redirectUri: String
	"The timezone of the user's browser."
	timezone: String!
	"The identifiers of the teams to auto-join."
	teamIdsToJoin: [String!]
	"Signup code."
	signupCode: String
	"An optional invite link for an organization used to populate available organizations."
	inviteLink: String
}

input CommentCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The comment content in markdown format."
	body: String
	"[Internal] The comment content as a Prosemirror document."
	bodyData: JSON
	"The issue to associate the comment with."
	issueId: String
	"The project update to associate the comment with."
	projectUpdateId: String
	"The document content to associate the comment with."
	documentContentId: String
	"The parent comment under which to nest a current comment."
	parentId: String
	"Create comment as a user with the provided name. This option is only available to OAuth applications creating comments in `actor=application` mode."
	createAsUser: String
	"Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode."
	displayIconUrl: String
	"The date when the comment was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now."
	createdAt: DateTime
	"Flag to prevent auto subscription to the issue the comment is created on."
	doNotSubscribeToIssue: Boolean
	"Flag to indicate this comment should be created on the issue's synced Slack comment thread. If no synced Slack comment thread exists, the mutation will fail."
	createOnSyncedSlackThread: Boolean
	"The text that this comment references. Only defined for inline comments."
	quotedText: String
}

input CommentUpdateInput {
	"The comment content."
	body: String
	"The comment content as a Prosemirror document."
	bodyData: JSON
	"[INTERNAL] The user who resolved this thread."
	resolvingUserId: String
	"[INTERNAL] The child comment that resolves this thread."
	resolvingCommentId: String
	"The text that this comment references. Only defined for inline comments."
	quotedText: String
}

input ContactCreateInput {
	"The type of support contact."
	type: String!
	"The message the user sent."
	message: String!
	"User's operating system."
	operatingSystem: String
	"User's browser information."
	browser: String
	"User's device information."
	device: String
	"User's Linear client information."
	clientVersion: String
	"How disappointed the user would be if they could no longer use Linear."
	disappointmentRating: Int
}

"[INTERNAL] Input for sending a message to the Linear Sales team."
input ContactSalesCreateInput {
	"Name of the person requesting information."
	name: String!
	"Work email of the person requesting information."
	email: String!
	"Size of the company."
	companySize: String
	"The message the user sent."
	message: String
}

"Issue priority sorting options."
input PrioritySort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
	"Whether to consider no priority as the highest or lowest priority"
	noPriorityFirst: Boolean = false
}

"How to treat NULL values, whether they should appear first or last"
enum PaginationNulls {
	first
	last
}

"Whether to sort in ascending or descending order"
enum PaginationSortOrder {
	Ascending
	Descending
}

"Issue estimate sorting options."
input EstimateSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue title sorting options."
input TitleSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue sorting options."
input LabelSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue SLA status sorting options."
input SlaStatusSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue creation date sorting options."
input CreatedAtSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue cycle sorting options."
input CycleSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
	"When set to true, cycles wil be ordered with a custom order. Current cycle comes first, followed by upcoming cycles in ASC order, followed by previous cycles in DESC order."
	currentCycleFirst: Boolean = false
}

"Issue update date sorting options."
input UpdatedAtSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue project milestone options."
input MilestoneSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue completion date sorting options."
input CompletedAtSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue assignee sorting options."
input AssigneeSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue due date sorting options."
input DueDateSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue project sorting options."
input ProjectSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue team sorting options."
input TeamSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue workflow state sorting options."
input WorkflowStateSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue manual sorting options."
input ManualSort {
	"Whether nulls should be sorted first or last"
	nulls: PaginationNulls = last
	"The order for the individual sort"
	order: PaginationSortOrder
}

"Issue filtering options."
input IssueSortInput {
	"Sort by priority"
	priority: PrioritySort
	"Sort by estimate"
	estimate: EstimateSort
	"Sort by issue title"
	title: TitleSort
	"Sort by label"
	label: LabelSort
	"Sort by SLA status"
	slaStatus: SlaStatusSort
	"Sort by issue creation date"
	createdAt: CreatedAtSort
	"Sort by issue update date"
	updatedAt: UpdatedAtSort
	"Sort by issue completion date"
	completedAt: CompletedAtSort
	"Sort by issue due date"
	dueDate: DueDateSort
	"Sort by Cycle start date"
	cycle: CycleSort
	"Sort by Project Milestone target date"
	milestone: MilestoneSort
	"Sort by assignee name"
	assignee: AssigneeSort
	"Sort by Project name"
	project: ProjectSort
	"Sort by Team name"
	team: TeamSort
	"Sort by manual order"
	manual: ManualSort
	"Sort by workflow state type"
	workflowState: WorkflowStateSort
}

input CustomViewCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the custom view."
	name: String!
	"The description of the custom view."
	description: String
	"The icon of the custom view."
	icon: String
	"The color of the icon of the custom view."
	color: String
	"The id of the team associated with the custom view."
	teamId: String
	"[Internal] The id of the project associated with the custom view."
	projectId: String
	"The owner of the custom view."
	ownerId: String
	"The filters applied to issues in the custom view."
	filters: JSONObject
	"The filter applied to issues in the custom view."
	filterData: JSONObject
	"The project filter applied to issues in the custom view."
	projectFilterData: JSONObject
	"Whether the custom view is shared with everyone in the organization."
	shared: Boolean
}

input CustomViewUpdateInput {
	"The name of the custom view."
	name: String
	"The description of the custom view."
	description: String
	"The icon of the custom view."
	icon: String
	"The color of the icon of the custom view."
	color: String
	"The id of the team associated with the custom view."
	teamId: String
	"[Internal] The id of the project associated with the custom view."
	projectId: String
	"The owner of the custom view."
	ownerId: String
	"The filters applied to issues in the custom view."
	filters: JSONObject
	"The filter applied to issues in the custom view."
	filterData: JSONObject
	"The project filter applied to issues in the custom view."
	projectFilterData: JSONObject
	"Whether the custom view is shared with everyone in the organization."
	shared: Boolean
}

input CycleCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The custom name of the cycle."
	name: String
	"The description of the cycle."
	description: String
	"The team to associate the cycle with."
	teamId: String!
	"The start date of the cycle."
	startsAt: DateTime!
	"The end date of the cycle."
	endsAt: DateTime!
	"The completion time of the cycle. If null, the cycle hasn't been completed."
	completedAt: DateTime
}

input CycleUpdateInput {
	"The custom name of the cycle."
	name: String
	"The description of the cycle."
	description: String
	"The start date of the cycle."
	startsAt: DateTime
	"The end date of the cycle."
	endsAt: DateTime
	"The end date of the cycle."
	completedAt: DateTime
}

"[DEPRECATED] Input for shifting all cycles by a certain number of days. Mutation is now deprecated."
input CycleShiftAllInput {
	"[DEPRECATED] The cycle id at which to start the shift."
	id: String!
	"[DEPRECATED] The number of days to shift the cycles by."
	daysToShift: Float!
}

input DocumentCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The title of the document."
	title: String!
	"The icon of the document."
	icon: String
	"The color of the icon."
	color: String
	"[Internal] The document content as a Prosemirror document."
	contentData: JSONObject
	"The document content as markdown."
	content: String
	"Related project for the document."
	projectId: String!
	"The ID of the last template applied to the document."
	lastAppliedTemplateId: String
	"The order of the item in the project resources list."
	sortOrder: Float
}

input DocumentUpdateInput {
	"The title of the document."
	title: String
	"The icon of the document."
	icon: String
	"The color of the icon."
	color: String
	"[Internal] The document content as a Prosemirror document."
	contentData: JSONObject
	"The document content as markdown."
	content: String
	"Related project for the document."
	projectId: String
	"The ID of the last template applied to the document."
	lastAppliedTemplateId: String
	"The time at which the document was hidden."
	hiddenAt: DateTime
	"The order of the item in the project resources list."
	sortOrder: Float
}

input EmailIntakeAddressCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier or key of the team this email address will intake issues for."
	teamId: String
	"The identifier of the template this email address will intake issues for."
	templateId: String
}

input EmailIntakeAddressUpdateInput {
	"Whether the email address is currently enabled. If set to false, the email address will be disabled and no longer accept incoming emails."
	enabled: Boolean!
}

input EmailUnsubscribeInput {
	"Email type to unsubscribed from."
	type: String!
	"The user's email validation token."
	token: String!
	"The identifier of the user."
	userId: String!
}

input EmojiCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the custom emoji."
	name: String!
	"The URL for the emoji."
	url: String!
}

"[INTERNAL] The properties of the initiativeToProject to create."
input InitiativeToProjectCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the project."
	projectId: String!
	"The identifier of the initiative."
	initiativeId: String!
	"The sort order for the project within its organization."
	sortOrder: Float
}

"[INTERNAL] The properties of the initiativeToProject to update."
input InitiativeToProjectUpdateInput {
	"The sort order for the project within its organization."
	sortOrder: Float
}

"[Internal] The properties of the initiative to create."
input InitiativeCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the initiative."
	name: String!
	"The description of the initiative."
	description: String
	"The owner of the initiative."
	ownerId: String
	"The sort order of the initiative within the organization."
	sortOrder: Float
	"The initiative's color."
	color: String
}

"[Internal] The properties of the initiative to update."
input InitiativeUpdateInput {
	"The name of the initiative."
	name: String
	"The description of the initiative."
	description: String
	"The owner of the initiative."
	ownerId: String
	"The sort order of the initiative within the organization."
	sortOrder: Float
	"The initiative's color."
	color: String
	"The estimated completion date of the initiative."
	targetDate: TimelessDate
}

input FavoriteCreateInput {
	"The identifier. If none is provided, the backend will generate one."
	id: String
	"The name of the favorite folder."
	folderName: String
	"The parent folder of the favorite."
	parentId: String
	"The identifier of the issue to favorite."
	issueId: String
	"[INTERNAL] The identifier of the facet to favorite."
	facetId: String
	"The identifier of the project to favorite."
	projectId: String
	"The tab of the project to favorite."
	projectTab: ProjectTab
	"The identifier of the project team to favorite."
	projectTeamId: String
	"The type of the predefined view to favorite."
	predefinedViewType: String
	"The identifier of team for the predefined view to favorite."
	predefinedViewTeamId: String
	"The identifier of the cycle to favorite."
	cycleId: String
	"The identifier of the custom view to favorite."
	customViewId: String
	"The identifier of the document to favorite."
	documentId: String
	"The identifier of the roadmap to favorite."
	roadmapId: String
	"[INTERNAL] The identifier of the initiative to favorite."
	initiativeId: String
	"The identifier of the label to favorite."
	labelId: String
	"The identifier of the user to favorite."
	userId: String
	"The position of the item in the favorites list."
	sortOrder: Float
}

input FavoriteUpdateInput {
	"The position of the item in the favorites list."
	sortOrder: Float
	"The identifier (in UUID v4 format) of the folder to move the favorite under."
	parentId: String
	"The name of the favorite folder."
	folderName: String
}

input GitAutomationStateCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The team associated with the automation state."
	teamId: String!
	"The associated workflow state. If null, will override default behaviour and take no action."
	stateId: String
	"[DEPRECATED] The target branch pattern. If null, all branches are targeted."
	branchPattern: String
	"The associated target branch. If null, all branches are targeted."
	targetBranchId: String
	"The event that triggers the automation."
	event: GitAutomationStates!
}

input GitAutomationStateUpdateInput {
	"The associated workflow state."
	stateId: String
	"[DEPRECATED] The target branch pattern. If null, all branches are targeted."
	branchPattern: String
	"The associated target branch. If null, all branches are targeted."
	targetBranchId: String
	"The event that triggers the automation."
	event: GitAutomationStates
}

input GitAutomationTargetBranchCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The team associated with the Git target branch automation."
	teamId: String!
	"The target branch pattern."
	branchPattern: String!
	"Whether the branch pattern is a regular expression."
	isRegex: Boolean = false
}

input GitAutomationTargetBranchUpdateInput {
	"The target branch pattern."
	branchPattern: String
	"Whether the branch pattern is a regular expression."
	isRegex: Boolean
}

input IntegrationRequestInput {
	"Email associated with the request."
	email: String
	"Name of the requested integration."
	name: String!
}

input JiraConfigurationInput {
	"The Jira personal access token."
	accessToken: String!
	"The Jira user's email address."
	email: String!
	"The Jira installation hostname."
	hostname: String!
	"The Jira project keys to scope the integration to."
	project: String
}

input JiraUpdateInput {
	"The id of the integration to update."
	id: String!
	"Whether to refresh Jira Projects for the integration."
	updateProjects: Boolean
	"Whether to refresh Jira metadata for the integration."
	updateMetadata: Boolean
}

input AirbyteConfigurationInput {
	"Linear export API key."
	apiKey: String!
}

input IntegrationsSettingsCreateInput {
	"Whether to send a Slack message when a new issue is created for the project or the team."
	slackIssueCreated: Boolean
	"Whether to send a Slack message when a comment is created on any of the project or team's issues."
	slackIssueNewComment: Boolean
	"Whether to send a Slack message when any of the project or team's issues change to completed or cancelled."
	slackIssueStatusChangedDone: Boolean
	"Whether to send a Slack message when any of the project or team's issues has a change in status."
	slackIssueStatusChangedAll: Boolean
	"Whether to send a Slack message when a project update is created."
	slackProjectUpdateCreated: Boolean
	"Whether to send a Slack message when a project update is created to team channels."
	slackProjectUpdateCreatedToTeam: Boolean
	"Whether to send a Slack message when a project update is created to workspace channel."
	slackProjectUpdateCreatedToWorkspace: Boolean
	"Whether to send a Slack message when a new issue is added to triage."
	slackIssueAddedToTriage: Boolean
	"Whether to send a Slack message when an SLA is at high risk."
	slackIssueSlaHighRisk: Boolean
	"Whether to receive notification when an SLA has breached on Slack."
	slackIssueSlaBreached: Boolean
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the team to create settings for."
	teamId: String
	"The identifier of the project to create settings for."
	projectId: String
}

input IntegrationsSettingsUpdateInput {
	"Whether to send a Slack message when a new issue is created for the project or the team."
	slackIssueCreated: Boolean
	"Whether to send a Slack message when a comment is created on any of the project or team's issues."
	slackIssueNewComment: Boolean
	"Whether to send a Slack message when any of the project or team's issues change to completed or cancelled."
	slackIssueStatusChangedDone: Boolean
	"Whether to send a Slack message when any of the project or team's issues has a change in status."
	slackIssueStatusChangedAll: Boolean
	"Whether to send a Slack message when a project update is created."
	slackProjectUpdateCreated: Boolean
	"Whether to send a Slack message when a project update is created to team channels."
	slackProjectUpdateCreatedToTeam: Boolean
	"Whether to send a Slack message when a project update is created to workspace channel."
	slackProjectUpdateCreatedToWorkspace: Boolean
	"Whether to send a Slack message when a new issue is added to triage."
	slackIssueAddedToTriage: Boolean
	"Whether to send a Slack message when an SLA is at high risk."
	slackIssueSlaHighRisk: Boolean
	"Whether to receive notification when an SLA has breached on Slack."
	slackIssueSlaBreached: Boolean
}

input IntegrationTemplateCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the integration."
	integrationId: String!
	"The identifier of the template."
	templateId: String!
	"The foreign identifier in the other service."
	foreignEntityId: String
}

"Issue import mapping input."
input IssueImportMappingInput {
	"The mapping configuration for users."
	users: JSONObject
	"The mapping configuration for workflow states."
	workflowStates: JSONObject
	"The mapping configuration for epics."
	epics: JSONObject
}

input IssueImportUpdateInput {
	"The mapping configuration for the import."
	mapping: JSONObject!
}

input IssueLabelCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the label."
	name: String!
	"The description of the label."
	description: String
	"The color of the label."
	color: String
	"The identifier of the parent label."
	parentId: String
	"The team associated with the label. If not given, the label will be associated with the entire workspace."
	teamId: String
}

input IssueLabelUpdateInput {
	"The name of the label."
	name: String
	"The description of the label."
	description: String
	"The identifier of the parent label."
	parentId: String
	"The color of the label."
	color: String
}

input IssueRelationCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The type of relation of the issue to the related issue."
	type: IssueRelationType!
	"The identifier of the issue that is related to another issue."
	issueId: String!
	"The identifier of the related issue."
	relatedIssueId: String!
}

"The type of the issue relation."
enum IssueRelationType {
	blocks
	duplicate
	related
}

input IssueRelationUpdateInput {
	"The type of relation of the issue to the related issue."
	type: String
	"The identifier of the issue that is related to another issue."
	issueId: String
	"The identifier of the related issue."
	relatedIssueId: String
}

input NotificationUpdateInput {
	"The time when notification was marked as read."
	readAt: DateTime
	"The time until a notification will be snoozed. After that it will appear in the inbox again."
	snoozedUntilAt: DateTime
	"The id of the project update related to the notification."
	projectUpdateId: String
}

"Describes the type and id of the entity to target for notifications."
input NotificationEntityInput {
	"The id of the issue related to the notification."
	issueId: String
	"The id of the project related to the notification."
	projectId: String
	"The id of the project update related to the notification."
	projectUpdateId: String
	"The id of the OAuth client approval related to the notification."
	oauthClientApprovalId: String
}

input NotificationSubscriptionCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the custom view to subscribe to."
	customViewId: String
	"The identifier of the cycle to subscribe to."
	cycleId: String
	"The identifier of the label to subscribe to."
	labelId: String
	"The identifier of the project to subscribe to."
	projectId: String
	"The identifier of the team to subscribe to."
	teamId: String
	"The identifier of the user to subscribe to."
	userId: String
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"The types of notifications of the subscription."
	notificationSubscriptionTypes: [String!]
	"Whether the subscription is active."
	active: Boolean
}

input NotificationSubscriptionUpdateInput {
	"The types of notifications of the subscription."
	notificationSubscriptionTypes: [String!]
	"Whether the subscription is active."
	active: Boolean
}

input OrganizationDomainCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The domain name to add."
	name: String!
	"The email address to which to send the verification code."
	verificationEmail: String
	"The authentication type this domain is for."
	authType: String = "general"
}

input OrganizationDomainVerificationInput {
	"The identifier in UUID v4 format of the domain being verified."
	organizationDomainId: String!
	"The verification code sent via email."
	verificationCode: String!
}

input OrganizationInviteCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The email of the invitee."
	email: String!
	"What user role the invite should grant."
	role: UserRoleType = user
	"The message to send to the invitee."
	message: String
	"The teams that the user has been invited to."
	teamIds: [String!]
	"[INTERNAL] Optional metadata about the invite."
	metadata: JSONObject
}

input OrganizationInviteUpdateInput {
	"The teams that the user has been invited to."
	teamIds: [String!]!
}

input OrganizationUpdateInput {
	"The name of the organization."
	name: String
	"The logo of the organization."
	logoUrl: String
	"The URL key of the organization."
	urlKey: String
	"How git branches are formatted. If null, default formatting will be used."
	gitBranchFormat: String
	"Whether the Git integration linkback messages should be sent for private repositories."
	gitLinkbackMessagesEnabled: Boolean
	"Whether the Git integration linkback messages should be sent for public repositories."
	gitPublicLinkbackMessagesEnabled: Boolean
	"Whether the organization is using roadmap."
	roadmapEnabled: Boolean
	"The frequency at which project updates are sent."
	projectUpdatesReminderFrequency: ProjectUpdateReminderFrequency
	"The day at which project updates are sent."
	projectUpdateRemindersDay: Day
	"The hour at which project updates are sent."
	projectUpdateRemindersHour: Float
	"The month at which the fiscal year starts."
	fiscalYearStartMonth: Float
	"Whether the organization has opted for reduced customer support attachment information."
	reducedPersonalInformation: Boolean
	"Whether the organization has opted for having to approve all OAuth applications for install."
	oauthAppReview: Boolean
	"Linear Preview feature flags."
	linearPreviewFlags: JSONObject
	"List of services that are allowed to be used for login."
	allowedAuthServices: [String!]
	"Internal. Whether SLAs have been enabled for the organization."
	slaEnabled: Boolean
	"Which day count to use for SLA calculation."
	slaDayCount: SLADayCountType
	"Whether member users are allowed to send invites."
	allowMembersToInvite: Boolean
}

input DeleteOrganizationInput {
	"The deletion code to confirm operation."
	deletionCode: String!
}

input ProjectLinkCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The URL of the link."
	url: String!
	"The label for the link."
	label: String!
	"Related project for the link."
	projectId: String!
	"The order of the item in the project resources list."
	sortOrder: Float
}

input ProjectLinkUpdateInput {
	"The URL of the link."
	url: String
	"The label for the link."
	label: String
	"The order of the item in the project resources list."
	sortOrder: Float
}

input ProjectMilestoneCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the project milestone."
	name: String!
	"The description of the project milestone in markdown format."
	description: String
	"[Internal] The description of the project milestone as a Prosemirror document."
	descriptionData: JSONObject
	"The planned target date of the project milestone."
	targetDate: TimelessDate
	"Related project for the project milestone."
	projectId: String!
	"The sort order for the project milestone within a project."
	sortOrder: Float
}

input ProjectMilestoneUpdateInput {
	"The name of the project milestone."
	name: String
	"The description of the project milestone in markdown format."
	description: String
	"[Internal] The description of the project milestone as a Prosemirror document."
	descriptionData: JSONObject
	"The planned target date of the project milestone."
	targetDate: TimelessDate
	"The sort order for the project milestone within a project."
	sortOrder: Float
}

input ProjectCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the project."
	name: String!
	"The icon of the project."
	icon: String
	"The color of the project."
	color: String
	"[DEPRECATED] The state of the project."
	state: String
	"The ID of the project status."
	statusId: String
	"The description for the project."
	description: String
	"The identifiers of the teams this project is associated with."
	teamIds: [String!]!
	"The ID of the issue from which that project is created."
	convertedFromIssueId: String
	"The ID of the last template applied to the project."
	lastAppliedTemplateId: String
	"The identifier of the project lead."
	leadId: String
	"The identifiers of the members of this project."
	memberIds: [String!]
	"The planned start date of the project."
	startDate: TimelessDate
	"[INTERNAL] The resolution of the project's start date."
	startDateResolution: DateResolutionType
	"The planned target date of the project."
	targetDate: TimelessDate
	"[INTERNAL] The resolution of the project's estimated completion date."
	targetDateResolution: DateResolutionType
	"The sort order for the project within shared views."
	sortOrder: Float
}

input ProjectUpdateInput {
	"[DEPRECATED] The state of the project."
	state: String
	"The ID of the project status."
	statusId: String
	"The name of the project."
	name: String
	"The description for the project."
	description: String
	"The ID of the issue from which that project is created."
	convertedFromIssueId: String
	"The ID of the last template applied to the project."
	lastAppliedTemplateId: String
	"The icon of the project."
	icon: String
	"The color of the project."
	color: String
	"The identifiers of the teams this project is associated with."
	teamIds: [String!]
	"The time until which project update reminders are paused."
	projectUpdateRemindersPausedUntilAt: DateTime
	"The identifier of the project lead."
	leadId: String
	"The identifiers of the members of this project."
	memberIds: [String!]
	"The planned start date of the project."
	startDate: TimelessDate
	"[INTERNAL] The resolution of the project's start date."
	startDateResolution: DateResolutionType
	"The planned target date of the project."
	targetDate: TimelessDate
	"[INTERNAL] The resolution of the project's estimated completion date."
	targetDateResolution: DateResolutionType
	"The date when the project was completed."
	completedAt: DateTime
	"The date when the project was canceled."
	canceledAt: DateTime
	"Whether to send new issue notifications to Slack."
	slackNewIssue: Boolean
	"Whether to send new issue comment notifications to Slack."
	slackIssueComments: Boolean
	"Whether to send issue status update notifications to Slack."
	slackIssueStatuses: Boolean
	"The sort order for the project in shared views."
	sortOrder: Float
}

input ProjectUpdateInteractionCreateInput {
	"The identifier. If none is provided, the backend will generate one."
	id: String
	"The id of the project update that has been interacted with."
	projectUpdateId: String!
	"The time at which the user read the project update."
	readAt: DateTime!
}

input ProjectUpdateCreateInput {
	"The identifier. If none is provided, the backend will generate one."
	id: String
	"The content of the project update in markdown format."
	body: String
	"[Internal] The content of the project update as a Prosemirror document."
	bodyData: JSON
	"The project to associate the project update with."
	projectId: String!
	"The health of the project at the time of the update."
	health: ProjectUpdateHealthType
	"Whether the diff between the current update and the previous one should be hidden."
	isDiffHidden: Boolean
}

input ProjectUpdateUpdateInput {
	"The content of the project update in markdown format."
	body: String
	"The content of the project update as a Prosemirror document."
	bodyData: JSON
	"The health of the project at the time of the update."
	health: ProjectUpdateHealthType
	"Whether the diff between the current update and the previous one should be hidden."
	isDiffHidden: Boolean
}

input PushSubscriptionCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The user identifier of the subscription."
	userId: String
	"The data of the subscription in stringified JSON format."
	data: String!
	"Whether this is a subscription payload for Google Cloud Messaging or Apple Push Notification service."
	type: PushSubscriptionType = web
}

"The different push subscription types."
enum PushSubscriptionType {
	web
	apple
	appleDevelopment
	firebase
}

input ReactionCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The emoji the user reacted with."
	emoji: String
	"The comment to associate the reaction with."
	commentId: String
	"The project update to associate the reaction with."
	projectUpdateId: String
	"The issue to associate the reaction with."
	issueId: String
}

input RoadmapCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the roadmap."
	name: String!
	"The description of the roadmap."
	description: String
	"The owner of the roadmap."
	ownerId: String
	"The sort order of the roadmap within the organization."
	sortOrder: Float
	"The roadmap's color."
	color: String
}

input RoadmapUpdateInput {
	"The name of the roadmap."
	name: String
	"The description of the roadmap."
	description: String
	"The owner of the roadmap."
	ownerId: String
	"The sort order of the roadmap within the organization."
	sortOrder: Float
	"The roadmap's color."
	color: String
}

input RoadmapToProjectCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the project."
	projectId: String!
	"The identifier of the roadmap."
	roadmapId: String!
	"The sort order for the project within its organization."
	sortOrder: Float
}

input RoadmapToProjectUpdateInput {
	"The sort order for the project within its organization."
	sortOrder: Float
}

input TeamMembershipCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the user associated with the membership."
	userId: String!
	"The identifier of the team associated with the membership."
	teamId: String!
	"Internal. Whether the user is the owner of the team."
	owner: Boolean
	"The position of the item in the users list."
	sortOrder: Float
}

input TeamMembershipUpdateInput {
	"Internal. Whether the user is the owner of the team."
	owner: Boolean
	"The position of the item in the users list."
	sortOrder: Float
}

input TeamCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the team."
	name: String!
	"The description of the team."
	description: String
	"The key of the team. If not given, the key will be generated based on the name of the team."
	key: String
	"The icon of the team."
	icon: String
	"The color of the team."
	color: String
	"The organization associated with the team."
	organizationId: String
	"Whether the team uses cycles."
	cyclesEnabled: Boolean
	"The day of the week that a new cycle starts."
	cycleStartDay: Float
	"The duration of each cycle in weeks."
	cycleDuration: Int
	"The cooldown time after each cycle in weeks."
	cycleCooldownTime: Int
	"Auto assign started issues to current active cycle setting."
	cycleIssueAutoAssignStarted: Boolean
	"Auto assign completed issues to current active cycle setting."
	cycleIssueAutoAssignCompleted: Boolean
	"Only allow issues issues with cycles in Active Issues."
	cycleLockToActive: Boolean
	"How many upcoming cycles to create."
	upcomingCycleCount: Float
	"Whether triage mode is enabled for the team."
	triageEnabled: Boolean
	"Whether an issue needs to have a priority set before leaving triage."
	requirePriorityToLeaveTriage: Boolean
	"The timezone of the team."
	timezone: String
	"Whether issues without priority should be sorted first."
	issueOrderingNoPriorityFirst: Boolean
	"The issue estimation type to use. Must be one of \"notUsed\", \"exponential\", \"fibonacci\", \"linear\", \"tShirt\"."
	issueEstimationType: String
	"Whether to allow zeros in issues estimates."
	issueEstimationAllowZero: Boolean
	"Whether to move issues to bottom of the column when changing state."
	setIssueSortOrderOnStateChange: String
	"Whether to add additional points to the estimate scale."
	issueEstimationExtended: Boolean
	"What to use as an default estimate for unestimated issues."
	defaultIssueEstimate: Float
	"Whether to group recent issue history entries."
	groupIssueHistory: Boolean
	"The identifier of the default template for members of this team."
	defaultTemplateForMembersId: String
	"The identifier of the default template for non-members of this team."
	defaultTemplateForNonMembersId: String
	"The identifier of the default project template of this team."
	defaultProjectTemplateId: String
	"Internal. Whether the team is private or not."
	private: Boolean
	"Period after which issues are automatically closed, in months."
	autoClosePeriod: Float
	"The canceled workflow state which auto closed issues will be set to."
	autoCloseStateId: String
	"Period after which closed and completed issues are automatically archived, in months. 0 means disabled."
	autoArchivePeriod: Float
	"The workflow state into which issues are moved when they are marked as a duplicate of another issue."
	markedAsDuplicateWorkflowStateId: String
}

input TeamUpdateInput {
	"The name of the team."
	name: String
	"The description of the team."
	description: String
	"The key of the team."
	key: String
	"The icon of the team."
	icon: String
	"The color of the team."
	color: String
	"Whether the team uses cycles."
	cyclesEnabled: Boolean
	"The day of the week that a new cycle starts."
	cycleStartDay: Float
	"The duration of each cycle in weeks."
	cycleDuration: Int
	"The cooldown time after each cycle in weeks."
	cycleCooldownTime: Int
	"Auto assign started issues to current active cycle setting."
	cycleIssueAutoAssignStarted: Boolean
	"Auto assign completed issues to current active cycle setting."
	cycleIssueAutoAssignCompleted: Boolean
	"Only allow issues with cycles in Active Issues."
	cycleLockToActive: Boolean
	"[DEPRECATED] Whether the first cycle should start in the current or the next week."
	cycleEnabledStartWeek: String
	"The date to begin cycles on."
	cycleEnabledStartDate: DateTime
	"How many upcoming cycles to create."
	upcomingCycleCount: Float
	"The timezone of the team."
	timezone: String
	"Whether issues without priority should be sorted first."
	issueOrderingNoPriorityFirst: Boolean
	"The issue estimation type to use. Must be one of \"notUsed\", \"exponential\", \"fibonacci\", \"linear\", \"tShirt\"."
	issueEstimationType: String
	"Whether to allow zeros in issues estimates."
	issueEstimationAllowZero: Boolean
	"Whether to move issues to bottom of the column when changing state."
	setIssueSortOrderOnStateChange: String
	"Whether to add additional points to the estimate scale."
	issueEstimationExtended: Boolean
	"What to use as an default estimate for unestimated issues."
	defaultIssueEstimate: Float
	"The workflow state into which issues are moved when a draft PR has been opened."
	draftWorkflowStateId: String
	"The workflow state into which issues are moved when a PR has been opened."
	startWorkflowStateId: String
	"The workflow state into which issues are moved when a review has been requested for the PR."
	reviewWorkflowStateId: String
	"The workflow state into which issues are moved when a PR is ready to be merged."
	mergeableWorkflowStateId: String
	"The workflow state into which issues are moved when a PR has been merged."
	mergeWorkflowStateId: String
	"Whether to send new issue notifications to Slack."
	slackNewIssue: Boolean
	"Whether to send new issue comment notifications to Slack."
	slackIssueComments: Boolean
	"Whether to send issue status update notifications to Slack."
	slackIssueStatuses: Boolean
	"Whether to group recent issue history entries."
	groupIssueHistory: Boolean
	"The identifier of the default template for members of this team."
	defaultTemplateForMembersId: String
	"The identifier of the default template for non-members of this team."
	defaultTemplateForNonMembersId: String
	"The identifier of the default project template of this team."
	defaultProjectTemplateId: String
	"Whether the team is private or not."
	private: Boolean
	"Whether triage mode is enabled for the team."
	triageEnabled: Boolean
	"Whether an issue needs to have a priority set before leaving triage."
	requirePriorityToLeaveTriage: Boolean
	"Default status for newly created issues."
	defaultIssueStateId: String
	"Period after which issues are automatically closed, in months."
	autoClosePeriod: Float
	"The canceled workflow state which auto closed issues will be set to."
	autoCloseStateId: String
	"Period after which closed and completed issues are automatically archived, in months."
	autoArchivePeriod: Float
	"The workflow state into which issues are moved when they are marked as a duplicate of another issue."
	markedAsDuplicateWorkflowStateId: String
	"Whether new users should join this team by default. Mutation restricted to workspace admins!"
	joinByDefault: Boolean
}

input TemplateCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The template type, e.g. 'issue'."
	type: String!
	"The identifier or key of the team associated with the template. If not given, the template will be shared across all teams."
	teamId: String
	"The template name."
	name: String!
	"The template description."
	description: String
	"The template data as JSON encoded attributes of the type of entity, such as an issue."
	templateData: JSON!
}

input TemplateUpdateInput {
	"The template name."
	name: String
	"The template description."
	description: String
	"The identifier or key of the team associated with the template. If set to null, the template will be shared across all teams."
	teamId: String
	"The template data as JSON encoded attributes of the type of entity, such as an issue."
	templateData: JSON
}

input TimeScheduleCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The name of the schedule."
	name: String!
	"The schedule entries."
	entries: [TimeScheduleEntryInput!]!
	"The unique identifier of the external schedule."
	externalId: String
	"The URL to the external schedule."
	externalUrl: String
}

input TimeScheduleUpdateInput {
	"The name of the schedule."
	name: String
	"The schedule entries."
	entries: [TimeScheduleEntryInput!]
	"The unique identifier of the external schedule."
	externalId: String
	"The URL to the external schedule."
	externalUrl: String
}

input TriageResponsibilityCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The identifier of the team associated with the triage responsibility."
	teamId: String!
	"The action to take when an issue is added to triage."
	action: String!
	"The manual selection of users responsible for triage."
	manualSelection: TriageResponsibilityManualSelectionInput
	"The identifier of the time schedule used for scheduling triage responsibility"
	timeScheduleId: String
}

input TriageResponsibilityUpdateInput {
	"The action to take when an issue is added to triage."
	action: String
	"The manual selection of users responsible for triage."
	manualSelection: TriageResponsibilityManualSelectionInput
	"The identifier of the time schedule used for scheduling triage responsibility."
	timeScheduleId: String
}

input UserUpdateInput {
	"The name of the user."
	name: String
	"The display name of the user."
	displayName: String
	"The avatar image URL of the user."
	avatarUrl: String
	"Whether the user account is active."
	active: Boolean
	"Reason for deactivation."
	disableReason: String
	"Whether the user account has admin privileges."
	admin: Boolean
	"The user description or a short bio."
	description: String
	"The emoji part of the user status."
	statusEmoji: String
	"The label part of the user status."
	statusLabel: String
	"When the user status should be cleared."
	statusUntilAt: DateTime
	"The local timezone of the user."
	timezone: String
}

input UserSettingsUpdateInput {
	"The user's settings."
	settings: JSONObject
	"The types of emails the user has unsubscribed from."
	unsubscribedFrom: [String!]
	"Whether this user is subscribed to changelog email or not."
	subscribedToChangelog: Boolean
	"Whether this user is subscribed to DPA emails or not."
	subscribedToDPA: Boolean
	"Whether this user is subscribed to invite accepted emails or not."
	subscribedToInviteAccepted: Boolean
	"Whether this user is subscribed to privacy and legal update emails or not."
	subscribedToPrivacyLegalUpdates: Boolean
	"Whether this user is subscribed to email notifications reminder or not."
	subscribedToUnreadNotificationsReminder: Boolean
	"The user's notification preferences."
	notificationPreferences: JSONObject
	"[Internal] The user's usage warning history."
	usageWarningHistory: JSONObject
}

input ViewPreferencesCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The type of view preferences (either user or organization level preferences)."
	type: ViewPreferencesType!
	"The view type of the view preferences are associated with."
	viewType: ViewType!
	"View preferences object."
	preferences: JSONObject!
	"The default parameters for the insight on that view."
	insights: JSONObject
	"The team these view preferences are associated with."
	teamId: String
	"The project these view preferences are associated with."
	projectId: String
	"The roadmap these view preferences are associated with."
	roadmapId: String
	"[Internal] The initiative these view preferences are associated with."
	initiativeId: String
	"The label these view preferences are associated with."
	labelId: String
	"The cycle these view preferences are associated with."
	cycleId: String
	"The custom view these view preferences are associated with."
	customViewId: String
	"The user profile these view preferences are associated with."
	userId: String
}

"The type of view preferences (either user or organization level preferences)."
enum ViewPreferencesType {
	organization
	user
}

"The client view this custom view is targeting."
enum ViewType {
	inbox
	myIssues
	myIssuesCreatedByMe
	myIssuesSubscribedTo
	myIssuesActivity
	userProfile
	userProfileCreatedByUser
	board
	completedCycle
	cycle
	project
	projectDocuments
	label
	triage
	activeIssues
	backlog
	allIssues
	customView
	customViews
	customRoadmap
	roadmap
	roadmaps
	roadmapAll
	roadmapClosed
	roadmapBacklog
	initiative
	initiatives
	projects
	projectsAll
	projectsBacklog
	projectsClosed
	search
	splitSearch
	teams
	archive
	quickView
	issueIdentifiers
}

input ViewPreferencesUpdateInput {
	"View preferences."
	preferences: JSONObject
	"The default parameters for the insight on that view."
	insights: JSONObject
}

input WebhookCreateInput {
	"Label for the webhook."
	label: String
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"Whether this webhook is enabled."
	enabled: Boolean = true
	"A secret token used to sign the webhook payload."
	secret: String
	"The URL that will be called on data changes."
	url: String!
	"List of resources the webhook should subscribe to."
	resourceTypes: [String!]!
	"The identifier or key of the team associated with the Webhook."
	teamId: String
	"Whether this webhook is enabled for all public teams."
	allPublicTeams: Boolean
}

input WebhookUpdateInput {
	"Label for the webhook."
	label: String
	"A secret token used to sign the webhook payload."
	secret: String
	"Whether this webhook is enabled."
	enabled: Boolean
	"The URL that will be called on data changes."
	url: String
	"List of resources the webhook should subscribe to."
	resourceTypes: [String!]
}

input WorkflowStateCreateInput {
	"The identifier in UUID v4 format. If none is provided, the backend will generate one."
	id: String
	"The workflow type."
	type: String!
	"The name of the state."
	name: String!
	"The color of the state."
	color: String!
	"The description of the state."
	description: String
	"The position of the state."
	position: Float
	"The team associated with the state."
	teamId: String!
}

input WorkflowStateUpdateInput {
	"The name of the state."
	name: String
	"The color of the state."
	color: String
	"The description of the state."
	description: String
	"The position of the state."
	position: Float
}

"An issue related notification."
type IssueNotification implements Notification & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Notification type."
	type: String!
	"The user that caused the notification."
	actor: User
	"The external user that caused the notification."
	externalUserActor: ExternalUser
	"The user that received the notification."
	user: User!
	"The time at when the user marked the notification as read. Null, if the the user hasn't read the notification"
	readAt: DateTime
	"""
	The time at when an email reminder for this notification was sent to the user. Null, if no email
	    reminder has been sent.
	"""
	emailedAt: DateTime
	"The time until a notification will be snoozed. After that it will appear in the inbox again."
	snoozedUntilAt: DateTime
	"The time at which a notification was unsnoozed.."
	unsnoozedAt: DateTime
	"The bot that caused the notification."
	botActor: ActorBot
	"Name of the reaction emoji related to the notification."
	reactionEmoji: String
	"The issue related to the notification."
	issue: Issue!
	"The comment related to the notification."
	comment: Comment
	"The team related to the issue notification."
	team: Team!
	"The subscriptions related to the notification."
	subscriptions: [NotificationSubscription!]
}

"A project related notification."
type ProjectNotification implements Notification & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Notification type."
	type: String!
	"The user that caused the notification."
	actor: User
	"The external user that caused the notification."
	externalUserActor: ExternalUser
	"The user that received the notification."
	user: User!
	"The time at when the user marked the notification as read. Null, if the the user hasn't read the notification"
	readAt: DateTime
	"""
	The time at when an email reminder for this notification was sent to the user. Null, if no email
	    reminder has been sent.
	"""
	emailedAt: DateTime
	"The time until a notification will be snoozed. After that it will appear in the inbox again."
	snoozedUntilAt: DateTime
	"The time at which a notification was unsnoozed.."
	unsnoozedAt: DateTime
	"The bot that caused the notification."
	botActor: ActorBot
	"The project related to the notification."
	project: Project!
	"The project update related to the notification."
	projectUpdate: ProjectUpdate
}

"An oauth client approval related notification."
type OauthClientApprovalNotification implements Notification & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"Notification type."
	type: String!
	"The user that caused the notification."
	actor: User
	"The external user that caused the notification."
	externalUserActor: ExternalUser
	"The user that received the notification."
	user: User!
	"The time at when the user marked the notification as read. Null, if the the user hasn't read the notification"
	readAt: DateTime
	"""
	The time at when an email reminder for this notification was sent to the user. Null, if no email
	    reminder has been sent.
	"""
	emailedAt: DateTime
	"The time until a notification will be snoozed. After that it will appear in the inbox again."
	snoozedUntilAt: DateTime
	"The time at which a notification was unsnoozed.."
	unsnoozedAt: DateTime
	"The bot that caused the notification."
	botActor: ActorBot
	"The OAuth client approval request related to the notification."
	oauthClientApproval: OauthClientApproval!
}

"A custom view notification subscription."
type CustomViewNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The custom view subscribed to."
	customView: CustomView!
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team associated with the notification subscription."
	team: Team
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

"A cycle notification subscription."
type CycleNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The cycle subscribed to."
	cycle: Cycle!
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team associated with the notification subscription."
	team: Team
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

"A label notification subscription."
type LabelNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The label subscribed to."
	label: IssueLabel!
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team associated with the notification subscription."
	team: Team
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

"A project notification subscription."
type ProjectNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The project subscribed to."
	project: Project!
	"The team associated with the notification subscription."
	team: Team
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

"A team notification subscription."
type TeamNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team subscribed to."
	team: Team!
	"The user view associated with the notification subscription."
	user: User
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

"A user notification subscription."
type UserNotificationSubscription implements NotificationSubscription & Entity & Node {
	"The unique identifier of the entity."
	id: ID!
	"The time at which the entity was created."
	createdAt: DateTime!
	"""
	The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	    for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	    been updated after creation.
	"""
	updatedAt: DateTime!
	"The time at which the entity was archived. Null if the entity has not been archived."
	archivedAt: DateTime
	"The user that subscribed to receive notifications."
	subscriber: User!
	"The contextual custom view associated with the notification subscription."
	customView: CustomView
	"The contextual cycle view associated with the notification subscription."
	cycle: Cycle
	"The contextual label view associated with the notification subscription."
	label: IssueLabel
	"The contextual project view associated with the notification subscription."
	project: Project
	"The team associated with the notification subscription."
	team: Team
	"The user subscribed to."
	user: User!
	"The type of view to which the notification subscription context is associated with."
	contextViewType: ContextViewType
	"The type of user view to which the notification subscription context is associated with."
	userContextViewType: UserContextViewType
	"Whether the subscription is active or not."
	active: Boolean!
	"The type of subscription."
	notificationSubscriptionTypes: [String!]!
}

type Query {
	"All API keys for the user."
	apiKeys(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ApiKeyConnection!
	"Get basic information for an application."
	applicationInfo(clientId: String!): Application!
	"[INTERNAL] Get basic information for a list of applications."
	applicationInfoByIds(ids: [String!]!): [Application!]!
	"[INTERNAL] Get information for a list of applications with memberships"
	applicationInfoWithMembershipsByIds(clientIds: [String!]!): [WorkspaceAuthorizedApplication!]!
	"Get information for an application and whether a user has approved it for the given scopes."
	applicationWithAuthorization(actor: String = "user", redirectUri: String, scope: [String!]!, clientId: String!): UserAuthorizedApplication!
	"[INTERNAL] Get all authorized applications for a user."
	authorizedApplications: [AuthorizedApplication!]!
	"[INTERNAL] Get non-internal authorized applications (with limited fields) for a workspace"
	workspaceAuthorizedApplications: [WorkspaceAuthorizedApplication!]!
	"""
	All issue attachments.
	
	To get attachments for a given URL, use `attachmentsForURL` query.
	"""
	attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
	"""
	
	One specific issue attachment.
	[Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
	"""
	attachment(id: String!): Attachment!
	"Returns issue attachments for a given `url`."
	attachmentsForURL(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, url: String!): AttachmentConnection!
	"""
	
	Query an issue by its associated attachment, and its id.
	
	"""
	attachmentIssue(id: String!): Issue! @deprecated(reason: "Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead.")
	"[Internal] Get a list of all unique attachment sources in the workspace."
	attachmentSources(teamId: String): AttachmentSourcesPayload!
	"List of audit entry types."
	auditEntryTypes: [AuditEntryType!]!
	"All audit log entries."
	auditEntries(filter: AuditEntryFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AuditEntryConnection!
	"Fetch users belonging to this user account."
	availableUsers: AuthResolverResponse!
	"User's active sessions."
	authenticationSessions: [AuthenticationSessionResponse!]!
	"Fetch the region for the organization."
	organizationRegion(id: String!): OrganizationRegionResponse!
	"Fetch SSO login URL for the email provided."
	ssoUrlFromEmail(isDesktop: Boolean, email: String!): SsoUrlFromEmailResponse!
	"All comments."
	comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
	"A specific comment."
	comment(id: String, issueId: String, hash: String): Comment!
	"Custom views for the user."
	customViews(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomViewConnection!
	"One specific custom view."
	customView(id: String!): CustomView!
	"[INTERNAL] Suggests metadata for a view based on it's filters."
	customViewDetailsSuggestion(modelName: String, filter: JSONObject!): CustomViewSuggestionPayload!
	"Whether a custom view has other subscribers than the current user in the organization."
	customViewHasSubscribers(id: String!): CustomViewHasSubscribersPayload!
	"All cycles."
	cycles(filter: CycleFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CycleConnection!
	"One specific cycle."
	cycle(id: String!): Cycle!
	"A collection of document content history entries."
	documentContentHistory(id: String!): DocumentContentHistoryPayload!
	"All documents in the workspace."
	documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
	"One specific document."
	document(id: String!): Document!
	"All custom emojis."
	emojis(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EmojiConnection!
	"A specific emoji."
	emoji(id: String!): Emoji!
	"All external users for the organization."
	externalUsers(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ExternalUserConnection!
	"One specific external user."
	externalUser(id: String!): ExternalUser!
	"[INTERNAL] returns a list of initiative to project entities."
	initiativeToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeToProjectConnection!
	"[INTERNAL] One specific initiativeToProject."
	initiativeToProject(id: String!): InitiativeToProject!
	"[Internal] All initiatives in the workspace."
	initiatives(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeConnection!
	"[Internal] One specific initiative."
	initiative(id: String!): Initiative!
	"The user's favorites."
	favorites(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FavoriteConnection!
	"One specific favorite."
	favorite(id: String!): Favorite!
	"All integrations."
	integrations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationConnection!
	"One specific integration."
	integration(id: String!): Integration!
	"Checks if the integration has all required scopes."
	integrationHasScopes(scopes: [String!]!, integrationId: String!): IntegrationHasScopesPayload!
	"All project updates."
	projectUpdates(filter: ProjectUpdateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
	"One specific set of settings."
	integrationsSettings(id: String!): IntegrationsSettings!
	"Template and integration connections."
	integrationTemplates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationTemplateConnection!
	"One specific integrationTemplate."
	integrationTemplate(id: String!): IntegrationTemplate!
	"Fetches the GitHub token, completing the OAuth flow."
	issueImportFinishGithubOAuth(code: String!): GithubOAuthTokenPayload!
	"Checks a CSV file validity against a specific import service."
	issueImportCheckCSV(csvUrl: String!, service: String!): IssueImportCheckPayload!
	"All issue labels."
	issueLabels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
	"One specific label."
	issueLabel(id: String!): IssueLabel!
	"All issue relationships."
	issueRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
	"One specific issue relation."
	issueRelation(id: String!): IssueRelation!
	"All issues."
	issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [IssueSortInput!]): IssueConnection!
	"One specific issue."
	issue(id: String!): Issue!
	"[DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future  use `searchIssues` instead."
	issueSearch(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, query: String): IssueConnection!
	"Find issue based on the VCS branch name."
	issueVcsBranchSearch(branchName: String!): Issue
	"Find issues that are related to a given Figma file key."
	issueFigmaFileKeySearch(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, fileKey: String!): IssueConnection!
	"Issue priority values and corresponding labels."
	issuePriorityValues: [IssuePriorityValue!]!
	"Suggests filters for an issue view based on a text prompt."
	issueFilterSuggestion(projectId: String, prompt: String!): IssueFilterSuggestionPayload!
	"All notifications."
	notifications(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): NotificationConnection!
	"One specific notification."
	notification(id: String!): Notification!
	"The user's notification subscriptions."
	notificationSubscriptions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): NotificationSubscriptionConnection!
	"One specific notification subscription."
	notificationSubscription(id: String!): NotificationSubscription!
	"[INTERNAL] Checks whether the domain can be claimed."
	organizationDomainClaimRequest(id: String!): OrganizationDomainClaimPayload!
	"All invites for the organization."
	organizationInvites(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): OrganizationInviteConnection!
	"One specific organization invite."
	organizationInvite(id: String!): OrganizationInvite!
	"One specific organization invite."
	organizationInviteDetails(id: String!): OrganizationInviteDetailsPayload!
	"The user's organization."
	organization: Organization!
	"Does the organization exist."
	organizationExists(urlKey: String!): OrganizationExistsPayload!
	"[Internal] All archived teams of the organization."
	archivedTeams: [Team!]!
	"All links for the project."
	projectLinks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLinkConnection!
	"One specific project link."
	projectLink(id: String!): ProjectLink!
	"All milestones for the project."
	projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
	"One specific project milestone."
	projectMilestone(id: String!): ProjectMilestone!
	"All projects."
	projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectConnection!
	"One specific project."
	project(id: String!): Project!
	"Suggests filters for a project view based on a text prompt."
	projectFilterSuggestion(prompt: String!): ProjectFilterSuggestionPayload!
	"All interactions on project updates."
	projectUpdateInteractions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateInteractionConnection!
	"A specific interaction on a project update."
	projectUpdateInteraction(id: String!): ProjectUpdateInteraction!
	"A specific project update."
	projectUpdate(id: String!): ProjectUpdate!
	"Sends a test push message."
	pushSubscriptionTest(targetMobile: Boolean = false, sendStrategy: SendStrategy = push): PushSubscriptionTestPayload!
	"The status of the rate limiter."
	rateLimitStatus: RateLimitPayload!
	"All roadmaps in the workspace."
	roadmaps(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): RoadmapConnection!
	"One specific roadmap."
	roadmap(id: String!): Roadmap!
	"Custom views for the user."
	roadmapToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): RoadmapToProjectConnection!
	"One specific roadmapToProject."
	roadmapToProject(id: String!): RoadmapToProject!
	"Search documents."
	searchDocuments(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, snippetSize: Float, includeComments: Boolean, teamId: String): DocumentSearchPayload!
	"Search projects."
	searchProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, snippetSize: Float, includeComments: Boolean, teamId: String): ProjectSearchPayload!
	"Search issues."
	searchIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, snippetSize: Float, includeComments: Boolean, teamId: String): IssueSearchPayload!
	"All team memberships."
	teamMemberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
	"One specific team membership."
	teamMembership(id: String!): TeamMembership!
	"All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user."
	teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to."
	administrableTeams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
	"One specific team."
	team(id: String!): Team!
	"All templates from all users."
	templates: [Template!]!
	"A specific template."
	template(id: String!): Template!
	"Returns all templates that are associated with the integration type."
	templatesForIntegration(integrationType: String!): [Template!]!
	"[ALPHA] All time schedules."
	timeSchedules(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TimeScheduleConnection!
	"[ALPHA] A specific time schedule."
	timeSchedule(id: String!): TimeSchedule!
	"[ALPHA] All triage responsibilities."
	triageResponsibilities(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TriageResponsibilityConnection!
	"[ALPHA] A specific triage responsibility."
	triageResponsibility(id: String!): TriageResponsibility!
	"All users for the organization."
	users(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
	"One specific user."
	user(id: String!): User!
	"The currently authenticated user."
	viewer: User!
	"The user's settings."
	userSettings: UserSettings!
	"All webhooks."
	webhooks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WebhookConnection!
	"A specific webhook."
	webhook(id: String!): Webhook!
	"All issue workflow states."
	workflowStates(filter: WorkflowStateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WorkflowStateConnection!
	"One specific state."
	workflowState(id: String!): WorkflowState!
}

union OrganizationInviteDetailsPayload = OrganizationInviteFullDetailsPayload | OrganizationAcceptedOrExpiredInviteDetailsPayload

enum SendStrategy {
	desktopThenPush
	desktopAndPush
	desktop
	push
}

type Mutation {
	"Creates a new API key."
	apiKeyCreate(input: ApiKeyCreateInput!): ApiKeyPayload!
	"Deletes an API key."
	apiKeyDelete(id: String!): DeletePayload!
	"Creates a new attachment, or updates existing if the same `url` and `issueId` is used."
	attachmentCreate(input: AttachmentCreateInput!): AttachmentPayload!
	"Updates an existing issue attachment."
	attachmentUpdate(input: AttachmentUpdateInput!, id: String!): AttachmentPayload!
	"Link any url to an issue."
	attachmentLinkURL(createAsUser: String, displayIconUrl: String, title: String, url: String!, issueId: String!, id: String): AttachmentPayload!
	"Link an existing GitLab MR to an issue."
	attachmentLinkGitLabMR(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!, projectPathWithNamespace: String!, number: Float!): AttachmentPayload!
	"Link a GitHub issue to a Linear issue."
	attachmentLinkGitHubIssue(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!): AttachmentPayload!
	"Link a GitHub pull request to an issue."
	attachmentLinkGitHubPR(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!, owner: String, repo: String, number: Float): AttachmentPayload!
	"Link an existing Zendesk ticket to an issue."
	attachmentLinkZendesk(createAsUser: String, displayIconUrl: String, title: String, ticketId: String!, issueId: String!, id: String): AttachmentPayload!
	"Link an existing Discord message to an issue."
	attachmentLinkDiscord(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, channelId: String!, messageId: String!, url: String!): AttachmentPayload!
	"Link an existing Slack message to an issue."
	attachmentLinkSlack(createAsUser: String, displayIconUrl: String, title: String, channel: String!, ts: String, latest: String!, issueId: String!, url: String!, id: String): AttachmentPayload!
	"Link an existing Front conversation to an issue."
	attachmentLinkFront(createAsUser: String, displayIconUrl: String, title: String, conversationId: String!, issueId: String!, id: String): FrontAttachmentPayload!
	"Link an existing Intercom conversation to an issue."
	attachmentLinkIntercom(createAsUser: String, displayIconUrl: String, title: String, conversationId: String!, id: String, issueId: String!): AttachmentPayload!
	"Link an existing Jira issue to an issue."
	attachmentLinkJiraIssue(issueId: String!, jiraIssueId: String!): AttachmentPayload!
	"[DEPRECATED] Archives an issue attachment."
	attachmentArchive(id: String!): AttachmentArchivePayload! @deprecated(reason: "This mutation is deprecated, please use `attachmentDelete` instead")
	"Deletes an issue attachment."
	attachmentDelete(id: String!): DeletePayload!
	"Finds or creates a new user account by email and sends an email with token."
	emailUserAccountAuthChallenge(input: EmailUserAccountAuthChallengeInput!): EmailUserAccountAuthChallengeResponse!
	"Authenticates a user account via email and authentication token."
	emailTokenUserAccountAuth(input: TokenUserAccountAuthInput!): AuthResolverResponse!
	"Authenticates a user account via email and authentication token for SAML."
	samlTokenUserAccountAuth(input: TokenUserAccountAuthInput!): AuthResolverResponse!
	"Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow."
	googleUserAccountAuth(input: GoogleUserAccountAuthInput!): AuthResolverResponse!
	"Creates an organization from onboarding."
	createOrganizationFromOnboarding(survey: OnboardingCustomerSurvey, input: CreateOrganizationInput!): CreateOrJoinOrganizationResponse!
	"Join an organization from onboarding."
	joinOrganizationFromOnboarding(input: JoinOrganizationInput!): CreateOrJoinOrganizationResponse!
	"Leave an organization."
	leaveOrganization(organizationId: String!): CreateOrJoinOrganizationResponse!
	"Logout the client."
	logout: LogoutResponse!
	"Logout an individual session with its ID."
	logoutSession(sessionId: String!): LogoutResponse!
	"Logout all of user's sessions including the active one."
	logoutAllSessions: LogoutResponse!
	"Logout all of user's sessions excluding the current one."
	logoutOtherSessions: LogoutResponse!
	"Creates a new comment."
	commentCreate(input: CommentCreateInput!): CommentPayload!
	"Updates a comment."
	commentUpdate(input: CommentUpdateInput!, id: String!): CommentPayload!
	"Deletes a comment."
	commentDelete(id: String!): DeletePayload!
	"Resolves a comment."
	commentResolve(resolvingCommentId: String, id: String!): CommentPayload!
	"Unresolves a comment."
	commentUnresolve(id: String!): CommentPayload!
	"Saves user message."
	contactCreate(input: ContactCreateInput!): ContactPayload!
	"[INTERNAL] Saves sales pricing inquiry to Front."
	contactSalesCreate(input: ContactSalesCreateInput!): ContactPayload!
	"Creates a new custom view."
	customViewCreate(input: CustomViewCreateInput!): CustomViewPayload!
	"Updates a custom view."
	customViewUpdate(input: CustomViewUpdateInput!, id: String!): CustomViewPayload!
	"Deletes a custom view."
	customViewDelete(id: String!): DeletePayload!
	"Creates a new cycle."
	cycleCreate(input: CycleCreateInput!): CyclePayload!
	"Updates a cycle."
	cycleUpdate(input: CycleUpdateInput!, id: String!): CyclePayload!
	"Archives a cycle."
	cycleArchive(id: String!): CycleArchivePayload!
	"[DEPRECATED] Shifts all cycles starts by a certain number of weeks."
	cycleShiftAll(input: CycleShiftAllInput!): CyclePayload!
	"Creates a new document."
	documentCreate(input: DocumentCreateInput!): DocumentPayload!
	"Updates a document."
	documentUpdate(input: DocumentUpdateInput!, id: String!): DocumentPayload!
	"Deletes a document."
	documentDelete(id: String!): DeletePayload!
	"Creates a new email intake address."
	emailIntakeAddressCreate(input: EmailIntakeAddressCreateInput!): EmailIntakeAddressPayload!
	"Rotates an existing email intake address."
	emailIntakeAddressRotate(id: String!): EmailIntakeAddressPayload!
	"Updates an existing email intake address."
	emailIntakeAddressUpdate(input: EmailIntakeAddressUpdateInput!, id: String!): EmailIntakeAddressPayload!
	"Deletes an email intake address object."
	emailIntakeAddressDelete(id: String!): DeletePayload!
	"Unsubscribes the user from one type of email."
	emailUnsubscribe(input: EmailUnsubscribeInput!): EmailUnsubscribePayload!
	"Creates a custom emoji."
	emojiCreate(input: EmojiCreateInput!): EmojiPayload!
	"Deletes an emoji."
	emojiDelete(id: String!): DeletePayload!
	"[INTERNAL] Creates a new initiativeToProject join."
	initiativeToProjectCreate(input: InitiativeToProjectCreateInput!): InitiativeToProjectPayload!
	"[INTERNAL] Updates a initiativeToProject."
	initiativeToProjectUpdate(input: InitiativeToProjectUpdateInput!, id: String!): InitiativeToProjectPayload!
	"[INTERNAL] Deletes a initiativeToProject."
	initiativeToProjectDelete(id: String!): DeletePayload!
	"[Internal] Creates a new initiative."
	initiativeCreate(input: InitiativeCreateInput!): InitiativePayload!
	"[Internal] Updates a initiative."
	initiativeUpdate(input: InitiativeUpdateInput!, id: String!): InitiativePayload!
	"[Internal] Archives a initiative."
	initiativeArchive(id: String!): InitiativeArchivePayload!
	"[Internal] Unarchives a initiative."
	initiativeUnarchive(id: String!): InitiativeArchivePayload!
	"[Internal] Deletes a initiative."
	initiativeDelete(id: String!): DeletePayload!
	"Creates a new favorite (project, cycle etc)."
	favoriteCreate(input: FavoriteCreateInput!): FavoritePayload!
	"Updates a favorite."
	favoriteUpdate(input: FavoriteUpdateInput!, id: String!): FavoritePayload!
	"Deletes a favorite reference."
	favoriteDelete(id: String!): DeletePayload!
	"XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage."
	fileUpload(metaData: JSON, makePublic: Boolean, size: Int!, contentType: String!, filename: String!): UploadPayload!
	"XHR request payload to upload a file for import, directly to Linear's cloud storage."
	importFileUpload(metaData: JSON, size: Int!, contentType: String!, filename: String!): UploadPayload!
	"Upload an image from an URL to Linear."
	imageUploadFromUrl(url: String!): ImageUploadFromUrlPayload!
	"Creates a new automation state."
	gitAutomationStateCreate(input: GitAutomationStateCreateInput!): GitAutomationStatePayload!
	"Updates an existing state."
	gitAutomationStateUpdate(input: GitAutomationStateUpdateInput!, id: String!): GitAutomationStatePayload!
	"Archives an automation state."
	gitAutomationStateDelete(id: String!): DeletePayload!
	"Creates a Git target branch automation."
	gitAutomationTargetBranchCreate(input: GitAutomationTargetBranchCreateInput!): GitAutomationTargetBranchPayload!
	"Updates an existing Git target branch automation."
	gitAutomationTargetBranchUpdate(input: GitAutomationTargetBranchUpdateInput!, id: String!): GitAutomationTargetBranchPayload!
	"Archives a Git target branch automation."
	gitAutomationTargetBranchDelete(id: String!): DeletePayload!
	"Requests a currently unavailable integration."
	integrationRequest(input: IntegrationRequestInput!): IntegrationRequestPayload!
	"[INTERNAL] Updates the integration."
	integrationSettingsUpdate(input: IntegrationSettingsInput!, id: String!): IntegrationPayload!
	"Generates a webhook for the GitHub commit integration."
	integrationGithubCommitCreate: GitHubCommitIntegrationPayload!
	"Connects the organization with the GitHub App."
	integrationGithubConnect(installationId: String!): IntegrationPayload!
	"Connects the organization with a GitLab Access Token."
	integrationGitlabConnect(gitlabUrl: String!, accessToken: String!): IntegrationPayload!
	"Creates an integration api key for Airbyte to connect with Linear."
	airbyteIntegrationConnect(input: AirbyteConfigurationInput!): IntegrationPayload!
	"[Internal] Connects the Google Calendar to the user to this Linear account via OAuth2."
	integrationGoogleCalendarPersonalConnect(code: String!): IntegrationPayload!
	"[INTERNAL] Connects the organization with a Jira Personal Access Token."
	jiraIntegrationConnect(input: JiraConfigurationInput!): IntegrationPayload!
	"[INTERNAL] Updates a Jira Integration."
	integrationJiraUpdate(input: JiraUpdateInput!): IntegrationPayload!
	"Connect your Jira account to Linear."
	integrationJiraPersonal(code: String, accessToken: String): IntegrationPayload!
	"Connect your GitHub account to Linear."
	integrationGitHubPersonal(code: String!): IntegrationPayload!
	"Integrates the organization with Intercom."
	integrationIntercom(domainUrl: String, redirectUri: String!, code: String!): IntegrationPayload!
	"Disconnects the organization from Intercom."
	integrationIntercomDelete: IntegrationPayload!
	"[DEPRECATED] Updates settings on the Intercom integration."
	integrationIntercomSettingsUpdate(input: IntercomSettingsInput!): IntegrationPayload! @deprecated(reason: "This mutation is deprecated, please use `integrationSettingsUpdate` instead")
	"Integrates the organization with Discord."
	integrationDiscord(redirectUri: String!, code: String!): IntegrationPayload!
	"[INTERNAL] Integrates the organization with Opsgenie."
	integrationOpsgenieConnect(apiKey: String!): IntegrationPayload!
	"[INTERNAL] Refresh Opsgenie schedule mappings."
	integrationOpsgenieRefreshScheduleMappings: IntegrationPayload!
	"[INTERNAL] Integrates the organization with PagerDuty."
	integrationPagerDutyConnect(code: String!, redirectUri: String!): IntegrationPayload!
	"[INTERNAL] Refresh PagerDuty schedule mappings."
	integrationPagerDutyRefreshScheduleMappings: IntegrationPayload!
	"Updates the organization's Slack integration."
	integrationUpdateSlack(redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates the organization with Slack."
	integrationSlack(shouldUseV2Auth: Boolean, redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates the organization with the Slack Asks app."
	integrationSlackAsks(redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates your personal notifications with Slack."
	integrationSlackPersonal(redirectUri: String!, code: String!): IntegrationPayload!
	"Connect a Slack channel to Asks."
	integrationAsksConnectChannel(redirectUri: String!, code: String!): AsksChannelConnectPayload!
	"Slack webhook integration."
	integrationSlackPost(shouldUseV2Auth: Boolean, redirectUri: String!, teamId: String!, code: String!): SlackChannelConnectPayload!
	"Slack integration for project notifications."
	integrationSlackProjectPost(service: String!, redirectUri: String!, projectId: String!, code: String!): SlackChannelConnectPayload!
	"Slack integration for organization level project update notifications."
	integrationSlackOrgProjectUpdatesPost(redirectUri: String!, code: String!): SlackChannelConnectPayload!
	"Imports custom emojis from your Slack workspace."
	integrationSlackImportEmojis(redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates the organization with Figma."
	integrationFigma(redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates the organization with Google Sheets."
	integrationGoogleSheets(code: String!): IntegrationPayload!
	"Manually update Google Sheets data."
	refreshGoogleSheetsData(id: String!): IntegrationPayload!
	"Integrates the organization with Sentry."
	integrationSentryConnect(organizationSlug: String!, code: String!, installationId: String!): IntegrationPayload!
	"Integrates the organization with Front."
	integrationFront(redirectUri: String!, code: String!): IntegrationPayload!
	"Integrates the organization with Zendesk."
	integrationZendesk(subdomain: String!, code: String!, scope: String!, redirectUri: String!): IntegrationPayload!
	"Enables Loom integration for the organization."
	integrationLoom: IntegrationPayload! @deprecated(reason: "Not available.")
	"Deletes an integration."
	integrationDelete(id: String!): DeletePayload!
	"Archives an integration."
	integrationArchive(id: String!): DeletePayload!
	"Creates new settings for one or more integrations."
	integrationsSettingsCreate(input: IntegrationsSettingsCreateInput!): IntegrationsSettingsPayload!
	"Updates settings related to integrations for a project or a team."
	integrationsSettingsUpdate(input: IntegrationsSettingsUpdateInput!, id: String!): IntegrationsSettingsPayload!
	"Creates a new integrationTemplate join."
	integrationTemplateCreate(input: IntegrationTemplateCreateInput!): IntegrationTemplatePayload!
	"Deletes a integrationTemplate."
	integrationTemplateDelete(id: String!): DeletePayload!
	"Kicks off a GitHub import job."
	issueImportCreateGithub(organizationId: String, teamId: String, teamName: String, githubToken: String!, githubRepoName: String!, githubRepoOwner: String!, githubShouldImportOrgProjects: Boolean, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
	"Kicks off a Jira import job."
	issueImportCreateJira(organizationId: String, teamId: String, teamName: String, jiraToken: String!, jiraProject: String!, jiraEmail: String!, jiraHostname: String!, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
	"Kicks off a Jira import job from a CSV."
	issueImportCreateCSVJira(organizationId: String, teamId: String, teamName: String, csvUrl: String!, jiraHostname: String, jiraToken: String, jiraEmail: String): IssueImportPayload!
	"Kicks off a Shortcut (formerly Clubhouse) import job."
	issueImportCreateClubhouse(organizationId: String, teamId: String, teamName: String, clubhouseToken: String!, clubhouseGroupName: String!, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
	"Kicks off an Asana import job."
	issueImportCreateAsana(organizationId: String, teamId: String, teamName: String, asanaToken: String!, asanaTeamName: String!, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
	"Deletes an import job."
	issueImportDelete(issueImportId: String!): IssueImportDeletePayload!
	"Kicks off import processing."
	issueImportProcess(mapping: JSONObject!, issueImportId: String!): IssueImportPayload!
	"Updates the mapping for the issue import."
	issueImportUpdate(input: IssueImportUpdateInput!, id: String!): IssueImportPayload!
	"Creates a new label."
	issueLabelCreate(replaceTeamLabels: Boolean, input: IssueLabelCreateInput!): IssueLabelPayload!
	"Updates an label."
	issueLabelUpdate(input: IssueLabelUpdateInput!, id: String!): IssueLabelPayload!
	"Deletes an issue label."
	issueLabelDelete(id: String!): DeletePayload!
	"Creates a new issue relation."
	issueRelationCreate(input: IssueRelationCreateInput!): IssueRelationPayload!
	"Updates an issue relation."
	issueRelationUpdate(input: IssueRelationUpdateInput!, id: String!): IssueRelationPayload!
	"Deletes an issue relation."
	issueRelationDelete(id: String!): DeletePayload!
	"Creates a new issue."
	issueCreate(input: IssueCreateInput!): IssuePayload!
	"Updates an issue."
	issueUpdate(input: IssueUpdateInput!, id: String!): IssuePayload!
	"Updates multiple issues at once."
	issueBatchUpdate(input: IssueUpdateInput!, ids: [UUID!]!): IssueBatchPayload!
	"Archives an issue."
	issueArchive(trash: Boolean, id: String!): IssueArchivePayload!
	"Unarchives an issue."
	issueUnarchive(id: String!): IssueArchivePayload!
	"Deletes (trashes) an issue."
	issueDelete(id: String!): IssueArchivePayload!
	"Adds a label to an issue."
	issueAddLabel(labelId: String!, id: String!): IssuePayload!
	"Removes a label from an issue."
	issueRemoveLabel(labelId: String!, id: String!): IssuePayload!
	"Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is reached."
	issueReminder(reminderAt: DateTime!, id: String!): IssuePayload!
	"Subscribes a user to an issue."
	issueSubscribe(userId: String, id: String!): IssuePayload!
	"Unsubscribes a user from an issue."
	issueUnsubscribe(userId: String, id: String!): IssuePayload!
	"[INTERNAL] Updates an issue description from the Front app to handle Front attachments correctly."
	issueDescriptionUpdateFromFront(description: String!, id: String!): IssuePayload!
	"Updates a notification."
	notificationUpdate(input: NotificationUpdateInput!, id: String!): NotificationPayload!
	"Marks all past notifications for the associated entity as read."
	notificationMarkReadAll(readAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
	"Marks all past notifications for the associated entity as unread."
	notificationMarkUnreadAll(input: NotificationEntityInput!): NotificationBatchActionPayload!
	"Snoozes a notification and all past notifications for the associated entity."
	notificationSnoozeAll(snoozedUntilAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
	"Unsnoozes a notification and all past notifications for the associated entity."
	notificationUnsnoozeAll(unsnoozedAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
	"Archives a notification."
	notificationArchive(id: String!): NotificationArchivePayload!
	"Archives all of the user's past notifications for the associated entity."
	notificationArchiveAll(input: NotificationEntityInput!): NotificationBatchActionPayload!
	"Unarchives a notification."
	notificationUnarchive(id: String!): NotificationArchivePayload!
	"Creates a new notification subscription for a cycle, custom view, label, project or team."
	notificationSubscriptionCreate(input: NotificationSubscriptionCreateInput!): NotificationSubscriptionPayload!
	"Updates a notification subscription."
	notificationSubscriptionUpdate(input: NotificationSubscriptionUpdateInput!, id: String!): NotificationSubscriptionPayload!
	"Deletes a notification subscription reference."
	notificationSubscriptionDelete(id: String!): DeletePayload! @deprecated(reason: "Update `notificationSubscription.active` to `false` instead.")
	"[INTERNAL] Verifies a domain claim."
	organizationDomainClaim(id: String!): OrganizationDomainSimplePayload!
	"[INTERNAL] Verifies a domain to be added to an organization."
	organizationDomainVerify(input: OrganizationDomainVerificationInput!): OrganizationDomainPayload!
	"[INTERNAL] Adds a domain to be allowed for an organization."
	organizationDomainCreate(triggerEmailVerification: Boolean, input: OrganizationDomainCreateInput!): OrganizationDomainPayload!
	"Deletes a domain."
	organizationDomainDelete(id: String!): DeletePayload!
	"Creates a new organization invite."
	organizationInviteCreate(input: OrganizationInviteCreateInput!): OrganizationInvitePayload!
	"Updates an organization invite."
	organizationInviteUpdate(input: OrganizationInviteUpdateInput!, id: String!): OrganizationInvitePayload!
	"Re-send an organization invite."
	resendOrganizationInvite(id: String!): DeletePayload!
	"Deletes an organization invite."
	organizationInviteDelete(id: String!): DeletePayload!
	"Updates the user's organization."
	organizationUpdate(input: OrganizationUpdateInput!): OrganizationPayload!
	"Get an organization's delete confirmation token. Administrator privileges required."
	organizationDeleteChallenge: OrganizationDeletePayload!
	"Delete's an organization. Administrator privileges required."
	organizationDelete(input: DeleteOrganizationInput!): OrganizationDeletePayload!
	"Cancels the deletion of an organization. Administrator privileges required."
	organizationCancelDelete: OrganizationCancelDeletePayload!
	"Starts a plus trial for the organization. Administrator privileges required."
	organizationStartPlusTrial: OrganizationStartPlusTrialPayload!
	"Creates a new project link."
	projectLinkCreate(input: ProjectLinkCreateInput!): ProjectLinkPayload!
	"Updates a project link."
	projectLinkUpdate(input: ProjectLinkUpdateInput!, id: String!): ProjectLinkPayload!
	"Deletes a project link."
	projectLinkDelete(id: String!): DeletePayload!
	"Creates a new project milestone."
	projectMilestoneCreate(input: ProjectMilestoneCreateInput!): ProjectMilestonePayload!
	"Updates a project milestone."
	projectMilestoneUpdate(input: ProjectMilestoneUpdateInput!, id: String!): ProjectMilestonePayload!
	"Deletes a project milestone."
	projectMilestoneDelete(id: String!): DeletePayload!
	"Creates a new project."
	projectCreate(connectSlackChannel: Boolean, input: ProjectCreateInput!): ProjectPayload!
	"Updates a project."
	projectUpdate(input: ProjectUpdateInput!, id: String!): ProjectPayload!
	"Deletes (trashes) a project."
	projectDelete(id: String!): ProjectArchivePayload!
	"Archives a project."
	projectArchive(trash: Boolean, id: String!): ProjectArchivePayload! @deprecated(reason: "Deprecated in favor of projectDelete.")
	"Unarchives a project."
	projectUnarchive(id: String!): ProjectArchivePayload!
	"Creates a new interaction on a project update."
	projectUpdateInteractionCreate(input: ProjectUpdateInteractionCreateInput!): ProjectUpdateInteractionPayload!
	"Creates a new project update."
	projectUpdateCreate(input: ProjectUpdateCreateInput!): ProjectUpdatePayload!
	"Updates a project update."
	projectUpdateUpdate(input: ProjectUpdateUpdateInput!, id: String!): ProjectUpdatePayload!
	"Deletes a project update."
	projectUpdateDelete(id: String!): DeletePayload!
	"Mark a project update as read."
	projectUpdateMarkAsRead(id: String!): ProjectUpdateWithInteractionPayload!
	"Create a notification to remind a user about a project update."
	createProjectUpdateReminder(userId: String, projectId: String!): ProjectUpdateReminderPayload!
	"Creates a push subscription."
	pushSubscriptionCreate(input: PushSubscriptionCreateInput!): PushSubscriptionPayload!
	"Deletes a push subscription."
	pushSubscriptionDelete(id: String!): PushSubscriptionPayload!
	"Creates a new reaction."
	reactionCreate(input: ReactionCreateInput!): ReactionPayload!
	"Deletes a reaction."
	reactionDelete(id: String!): DeletePayload!
	"Create CSV export report for the organization."
	createCsvExportReport(includePrivateTeamIds: [String!]): CreateCsvExportReportPayload!
	"Creates a new roadmap."
	roadmapCreate(input: RoadmapCreateInput!): RoadmapPayload!
	"Updates a roadmap."
	roadmapUpdate(input: RoadmapUpdateInput!, id: String!): RoadmapPayload!
	"Archives a roadmap."
	roadmapArchive(id: String!): RoadmapArchivePayload!
	"Unarchives a roadmap."
	roadmapUnarchive(id: String!): RoadmapArchivePayload!
	"Deletes a roadmap."
	roadmapDelete(id: String!): DeletePayload!
	"Creates a new roadmapToProject join."
	roadmapToProjectCreate(input: RoadmapToProjectCreateInput!): RoadmapToProjectPayload!
	"Updates a roadmapToProject."
	roadmapToProjectUpdate(input: RoadmapToProjectUpdateInput!, id: String!): RoadmapToProjectPayload!
	"Deletes a roadmapToProject."
	roadmapToProjectDelete(id: String!): DeletePayload!
	"Deletes a previously used team key."
	teamKeyDelete(id: String!): DeletePayload!
	"Creates a new team membership."
	teamMembershipCreate(input: TeamMembershipCreateInput!): TeamMembershipPayload!
	"Updates a team membership."
	teamMembershipUpdate(input: TeamMembershipUpdateInput!, id: String!): TeamMembershipPayload!
	"Deletes a team membership."
	teamMembershipDelete(id: String!): DeletePayload!
	"Creates a new team. The user who creates the team will automatically be added as a member to the newly created team."
	teamCreate(copySettingsFromTeamId: String, input: TeamCreateInput!): TeamPayload!
	"Updates a team."
	teamUpdate(input: TeamUpdateInput!, id: String!): TeamPayload!
	"Deletes a team."
	teamDelete(id: String!): DeletePayload!
	"Unarchives a team and cancels deletion."
	teamUnarchive(id: String!): TeamArchivePayload!
	"Deletes team's cycles data"
	teamCyclesDelete(id: String!): TeamPayload!
	"Creates a new template."
	templateCreate(input: TemplateCreateInput!): TemplatePayload!
	"Updates an existing template."
	templateUpdate(input: TemplateUpdateInput!, id: String!): TemplatePayload!
	"Deletes a template."
	templateDelete(id: String!): DeletePayload!
	"[ALPHA] Creates a new time schedule."
	timeScheduleCreate(input: TimeScheduleCreateInput!): TimeSchedulePayload!
	"[ALPHA] Updates a time schedule."
	timeScheduleUpdate(input: TimeScheduleUpdateInput!, id: String!): TimeSchedulePayload!
	"[ALPHA] Upsert an external time schedule."
	timeScheduleUpsertExternal(input: TimeScheduleUpdateInput!, externalId: String!): TimeSchedulePayload!
	"[ALPHA] Deletes a time schedule."
	timeScheduleDelete(id: String!): DeletePayload!
	"[ALPHA] Refresh the integration schedule information."
	timeScheduleRefreshIntegrationSchedule(id: String!): TimeSchedulePayload!
	"[ALPHA] Creates a new triage responsibility."
	triageResponsibilityCreate(input: TriageResponsibilityCreateInput!): TriageResponsibilityPayload!
	"[ALPHA] Updates an existing triage responsibility."
	triageResponsibilityUpdate(input: TriageResponsibilityUpdateInput!, id: String!): TriageResponsibilityPayload!
	"[ALPHA] Deletes a triage responsibility."
	triageResponsibilityDelete(id: String!): DeletePayload!
	"Updates a user. Only available to organization admins and the user themselves."
	userUpdate(input: UserUpdateInput!, id: String!): UserPayload!
	"Connects the Discord user to this Linear account via OAuth2."
	userDiscordConnect(redirectUri: String!, code: String!): UserPayload!
	"Disconnects the external user from this Linear account."
	userExternalUserDisconnect(service: String!): UserPayload!
	"Makes user an admin. Can only be called by an admin."
	userPromoteAdmin(id: String!): UserAdminPayload!
	"Makes user a regular user. Can only be called by an admin."
	userDemoteAdmin(id: String!): UserAdminPayload!
	"Makes user a regular user. Can only be called by an admin."
	userPromoteMember(id: String!): UserAdminPayload!
	"Makes user a guest. Can only be called by an admin."
	userDemoteMember(id: String!): UserAdminPayload!
	"Suspends a user. Can only be called by an admin."
	userSuspend(id: String!): UserAdminPayload!
	"Un-suspends a user. Can only be called by an admin."
	userUnsuspend(id: String!): UserAdminPayload!
	"Updates the user's settings."
	userSettingsUpdate(input: UserSettingsUpdateInput!, id: String!): UserSettingsPayload!
	"[Deprecated] Updates a user's settings flag."
	userSettingsFlagIncrement(flag: String!): UserSettingsFlagPayload!
	"Resets user's setting flags."
	userSettingsFlagsReset(flags: [UserFlagType!]): UserSettingsFlagsResetPayload!
	"Updates a user's settings flag."
	userFlagUpdate(operation: UserFlagUpdateOperation!, flag: UserFlagType!): UserSettingsFlagPayload!
	"Creates a new ViewPreferences object."
	viewPreferencesCreate(input: ViewPreferencesCreateInput!): ViewPreferencesPayload!
	"Updates an existing ViewPreferences object."
	viewPreferencesUpdate(input: ViewPreferencesUpdateInput!, id: String!): ViewPreferencesPayload!
	"Deletes a ViewPreferences."
	viewPreferencesDelete(id: String!): DeletePayload!
	"Creates a new webhook."
	webhookCreate(input: WebhookCreateInput!): WebhookPayload!
	"Updates an existing Webhook."
	webhookUpdate(input: WebhookUpdateInput!, id: String!): WebhookPayload!
	"Deletes a Webhook."
	webhookDelete(id: String!): DeletePayload!
	"Creates a new state, adding it to the workflow of a team."
	workflowStateCreate(input: WorkflowStateCreateInput!): WorkflowStatePayload!
	"Updates a state."
	workflowStateUpdate(input: WorkflowStateUpdateInput!, id: String!): WorkflowStatePayload!
	"Archives a state. Only states with issues that have all been archived can be archived."
	workflowStateArchive(id: String!): WorkflowStateArchivePayload!
}

"A universally unique identifier as specified by RFC 4122."
scalar UUID

"The types of flags that the user can have."
enum UserFlagType {
	updatedSlackThreadSyncIntegration
	completedOnboarding
	desktopInstalled
	teamsPageIntroductionDismissed
	joinTeamIntroductionDismissed
	desktopDownloadToastDismissed
	emptyBacklogDismissed
	emptyCustomViewsDismissed
	emptyActiveIssuesDismissed
	emptyMyIssuesDismissed
	triageWelcomeDismissed
	cycleWelcomeDismissed
	projectWelcomeDismissed
	projectBacklogWelcomeDismissed
	projectUpdatesWelcomeDismissed
	analyticsWelcomeDismissed
	insightsWelcomeDismissed
	insightsHelpDismissed
	figmaPromptDismissed
	issueMovePromptCompleted
	migrateThemePreference
	listSelectionTip
	canPlaySnake
	canPlayTetris
	importBannerDismissed
	tryInvitePeopleDismissed
	tryRoadmapsDismissed
	tryCyclesDismissed
	tryTriageDismissed
	tryGithubDismissed
	rewindBannerDismissed
	helpIslandFeatureInsightsDismissed
	dueDateShortcutMigration
	slackCommentReactionTipShown
	issueLabelSuggestionUsed
	threadedCommentsNudgeIsSeen
	desktopTabsOnboardingDismissed
	milestoneOnboardingIsSeenAndDismissed
	projectBoardOnboardingIsSeenAndDismissed
	figmaPluginBannerDismissed
	all
}

"Operations that can be applied to UserFlagType."
enum UserFlagUpdateOperation {
	incr
	decr
	clear
	lock
}

